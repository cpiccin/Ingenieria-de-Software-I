# Patrones de dise침o
**Creational patterns** provide object creation mechanisms that increase flexibility and reuse of existing code.

**Structural patterns** explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.

**Behavioral patterns** take care of effective communication and the assignment of responsibilities between objects.


# Patrones creacionales
Se enfocan en c칩mo crear objetos, separando el proceso de creaci칩n de su uso. Abordan el problema de c칩mo crear objetos de manera flexible y reutilizable, proporcionando mecanismos para la creaci칩n de objetos que no se basan en la creaci칩n directa de objetos. 

## Factory
**Aplicabilidad**: 
- Cuando desde una clase se desee crear y usar objetos sin que la misma quede acoplada a las clases de estos.
- Cuando una clase no pueda anticipar la clase de objetos que debe crear.
- Cuando una clase quiera que sean sus subclases las que especifiquen los objetos que crea.

**Estructura**

![image](https://github.com/user-attachments/assets/01fbcbc5-c789-4062-9714-e7ea87c8b27a)

- **Product** declara la interfaz, que es comun a todos los objetos que puede producir la clase creadora y sus subclases
- Los **ConcreteProduct** son distintas implementaciones de Product
- La clase **Creator** declara el metodo factory que devuelve nuevos objetos de producto. Coincide el tipo de retorno con el tipo de la interfaz de producto
- Los **ConcreteCreators** sobreescriben el Factory Method, devolviendo un tipo diferente de producto

*Efectos deseados*: El patr칩n sigue el Principio de Responsabilidad 칔nica (la creaci칩n de los
objetos se concentra en las f치bricas). Se disminuye el acoplamiento entre las clases. Y sigue el Principio de abierto/cerrado. Puedes incorporar nuevos tipos de productos en el programa sin descomponer el c칩digo cliente existente.

### Ejemplo 1
**Situacion**: Una aplicaci칩n de mensajer칤a fue dise침ada inicialmente solo para enviar correos electr칩nicos. Toda la l칩gica de env칤o de mensajes, validaci칩n y formato estaba escrita directamente en una clase MensajeEmail.

Los usuarios comenzaron a solicitar otros tipos de mensajes, como SMS y WhatsApp. Para agregarlos, el equipo tuvo que llenar el c칩digo de condicionales que preguntaban por el tipo de mensaje: `"si es email, hacer esto... si es SMS, hacer esto otro..."`. Esto hizo que el sistema fuera dif칤cil de mantener, dif칤cil de escalar, y muy propenso a errores cada vez que se quer칤a agregar un nuevo tipo de mensaje.

El problema central era que el c칩digo estaba fuertemente **acoplado** a los tipos concretos de mensajes. Cada vez que se agregaba uno nuevo, era necesario modificar varias partes del sistema, violando el principio de abierto/cerrado (el c칩digo deber칤a estar abierto a la extensi칩n pero cerrado a la modificaci칩n).

**Soluci칩n**: En vez de instanciar directamente (new MensajeEmail()), delegamos la creaci칩n del objeto a un m칠todo f치brica. Este m칠todo es declarado en una clase abstracta (o interfaz), y cada tipo de mensaje tendr치 su propia clase que implemente ese m칠todo, devolviendo el objeto adecuado.

**En codigo**

- Product
```
public interface Mensaje {
    void enviar(String destinatario, String contenido);
}
```
- ConcreteProduct
```
public class MensajeEmail implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando Email a " + destinatario + ": " + contenido);
    }
}

public class MensajeSMS implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando SMS a " + destinatario + ": " + contenido);
    }
}
```
- Creator
```
public abstract class MensajeFactory {
    // M칠todo Factory
    public abstract Mensaje crearMensaje();
}
```
- ConcreteCreator
```
public class EmailFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeEmail();
    }
}

public class SMSFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeSMS();
    }
}
```
- Cliente
```
public class Main {
    public static void main(String[] args) {
        MensajeFactory factory = new EmailFactory();  // puede cambiarse por SMSFactory
        Mensaje mensaje = factory.crearMensaje();
        mensaje.enviar("ana@example.com", "Hola Ana!");
    }
}
```


## Abstract Factory
**Aplicabilidad**
- Cuando un sistema deba ser independiente de c칩mo se crean, componen y representan sus productos.
- Cuando un sistema deba ser configurado con una familia de productos de entre varias.
- Cuando una familia de objetos producto relacionados est칠 dise침ada para ser usada conjuntamente, y sea necesario hacer cumplir esta restricci칩n.
- Cuando se quiera proporcionar una biblioteca de clases de productos, y solo se quiera revelar sus interfaces, no sus implementaciones

**Estructura**

![image](https://github.com/user-attachments/assets/4e57c3d4-0f34-45d9-84e6-01ea069573e8)

- Los **AbstractProduct** declaran interfaces para un grupo de productos diferentes pero relacionados que forman una familia de productos
- Los **Products**, productos concretos, son las distintas implementaciones de productos abstractos agrupados por variantes. Cada producto abstracto debe implementarse en todas las variantes dadas
- La **AbstractFactory** declara un grupo de metodos para crear cada uno de los productos abstractos
- Las **ConcreteFactory** implementan los m칠todos de creaci칩n de la f치brica abstracta. Cada f치brica concreta se corresponde con una variante espec칤fica de los productos y crea tan solo dichas variantes de los productos.
 -El **Cliente** puede funcionar con cualquier variante f치brica/producto concreta, siempre y cuando se comunique con sus objetos a trav칠s de interfaces abstractas.
  
### Ejemplo 1
**Situacion**: Una empresa est치 desarrollando una aplicaci칩n de interfaz gr치fica que debe poder funcionar en Windows y en Mac. Al principio, todo fue hecho para Windows, y se usaban botones, men칰s y ventanas espec칤ficas de Windows.

Cuando se quiso soportar Mac, el equipo se dio cuenta de que el c칩digo estaba lleno de condicionales como if (sistema == WINDOWS) y if (sistema == MAC), para decidir qu칠 componente gr치fico usar.
Esto hizo el c칩digo dif칤cil de mantener, muy repetitivo, y fr치gil ante cambios.

El problema era que todo el sistema estaba acoplado a familias de objetos concretos: botones, men칰s, ventanas espec칤ficas de cada sistema operativo.

**Solucion**: Definir una familia de objetos relacionados (por ejemplo, todos los componentes gr치ficos de Windows o de Mac) mediante una interfaz com칰n, y delegar la creaci칩n de todos ellos a una f치brica abstracta. As칤 se pueden crear objetos sin que el cliente tenga que saber qu칠 sistema operativo se est치 usando.

**En codigo**: interfaz gr치fica con dos temas: TemaClaro y TemaOscuro. Cada tema tiene su Bot칩n y su Men칰.
- **AbstractProduct**
```
public interface Boton {
    void dibujar();
}

public interface Menu {
    void desplegar();
}
```
- **Product**
```
public class BotonClaro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot칩n claro");
    }
}

public class BotonOscuro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot칩n oscuro");
    }
}

public class MenuClaro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men칰 claro");
    }
}

public class MenuOscuro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men칰 oscuro");
    }
}
```
- **AbstractFactory**
```
public interface GUIFactory {
    Boton crearBoton();
    Menu crearMenu();
}
```
- **ConcreteFactory**
```
public class TemaClaroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonClaro();
    }

    public Menu crearMenu() {
        return new MenuClaro();
    }
}

public class TemaOscuroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonOscuro();
    }

    public Menu crearMenu() {
        return new MenuOscuro();
    }
}
```
- **Client**
```
public class Aplicacion {
    private Boton boton;
    private Menu menu;

    public Aplicacion(GUIFactory factory) {
        boton = factory.crearBoton();
        menu = factory.crearMenu();
    }

    public void mostrarUI() {
        boton.dibujar();
        menu.desplegar();
    }

    public static void main(String[] args) {
        GUIFactory factory = new TemaOscuroFactory(); // cambia por TemaClaroFactory
        Aplicacion app = new Aplicacion(factory);
        app.mostrarUI();
    }
}
```
- Main
```
public class Main {
    public static void main(String[] args) {
        GUIFactory factory;

        // Supongamos que detectamos tema oscuro
        factory = new TemaOscuroFactory();  // 游녣游낖 decide la variante

        Aplicacion app = new Aplicacion(factory);  // 游녣游낖 se inyecta la f치brica
        app.dibujarUI();  // 游녣游낖 la app usa los productos, sin saber cu치les
    }
}
```

## Builder

![image](https://github.com/user-attachments/assets/ba6cec00-0e9d-4b06-9fff-3f3fa8ba3b3b)

## Singleton



# Patrones estructurales
Son soluciones reutilizables que ayudan a resolver problemas comunes en la construcci칩n de software al definir c칩mo se componen las clases y objetos para crear estructuras complejas. Se enfocan en la estructura de clases y objetos, utilizando herramientas para ensamblar objetos y clases en estructuras m치s grandes. 

Facilitan el dise침o al identificar una forma simple de realizar relaciones entre entidades

## Decorator

## Adapter 

# Patrones de comportamiento
Son patrones que definen c칩mo los objetos interact칰an y se comunican entre s칤, centr치ndose en la asignaci칩n de responsabilidades y la implementaci칩n de algoritmos. Se enfoca en como las clases y objetos se comunican entre ellas.

## Null object

## State

## Strategy

## Template Method

## Interpreter

![image](https://github.com/user-attachments/assets/c6b06a9f-ef37-4085-8698-ef1e214cd1cd)

## Visitor

## Observer
