# Patrones de dise√±o
**Creational patterns** provide object creation mechanisms that increase flexibility and reuse of existing code.

**Structural patterns** explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.

**Behavioral patterns** take care of effective communication and the assignment of responsibilities between objects.


# Patrones creacionales
Se enfocan en c√≥mo crear objetos, separando el proceso de creaci√≥n de su uso. Abordan el problema de c√≥mo crear objetos de manera flexible y reutilizable, proporcionando mecanismos para la creaci√≥n de objetos que no se basan en la creaci√≥n directa de objetos. 

## Factory
**Aplicabilidad**: 
- Cuando desde una clase se desee crear y usar objetos sin que la misma quede acoplada a las clases de estos.
- Cuando una clase no pueda anticipar la clase de objetos que debe crear.
- Cuando una clase quiera que sean sus subclases las que especifiquen los objetos que crea.

**Estructura**

![image](https://github.com/user-attachments/assets/01fbcbc5-c789-4062-9714-e7ea87c8b27a)

- **Product** declara la interfaz, que es comun a todos los objetos que puede producir la clase creadora y sus subclases
- Los **ConcreteProduct** son distintas implementaciones de Product
- La clase **Creator** declara el metodo factory que devuelve nuevos objetos de producto. Coincide el tipo de retorno con el tipo de la interfaz de producto
- Los **ConcreteCreators** sobreescriben el Factory Method, devolviendo un tipo diferente de producto

*Efectos deseados*: El patr√≥n sigue el Principio de Responsabilidad √önica (la creaci√≥n de los
objetos se concentra en las f√°bricas). Se disminuye el acoplamiento entre las clases. Y sigue el Principio de abierto/cerrado. Puedes incorporar nuevos tipos de productos en el programa sin descomponer el c√≥digo cliente existente.

### Ejemplo 1
**Situacion**: Una aplicaci√≥n de mensajer√≠a fue dise√±ada inicialmente solo para enviar correos electr√≥nicos. Toda la l√≥gica de env√≠o de mensajes, validaci√≥n y formato estaba escrita directamente en una clase MensajeEmail.

Los usuarios comenzaron a solicitar otros tipos de mensajes, como SMS y WhatsApp. Para agregarlos, el equipo tuvo que llenar el c√≥digo de condicionales que preguntaban por el tipo de mensaje: `"si es email, hacer esto... si es SMS, hacer esto otro..."`. Esto hizo que el sistema fuera dif√≠cil de mantener, dif√≠cil de escalar, y muy propenso a errores cada vez que se quer√≠a agregar un nuevo tipo de mensaje.

El problema central era que el c√≥digo estaba fuertemente **acoplado** a los tipos concretos de mensajes. Cada vez que se agregaba uno nuevo, era necesario modificar varias partes del sistema, violando el principio de abierto/cerrado (el c√≥digo deber√≠a estar abierto a la extensi√≥n pero cerrado a la modificaci√≥n).

**Soluci√≥n**: En vez de instanciar directamente (new MensajeEmail()), delegamos la creaci√≥n del objeto a un m√©todo f√°brica. Este m√©todo es declarado en una clase abstracta (o interfaz), y cada tipo de mensaje tendr√° su propia clase que implemente ese m√©todo, devolviendo el objeto adecuado.

**En codigo**

- **Product**
```
public interface Mensaje {
    void enviar(String destinatario, String contenido);
}
```
- **ConcreteProduct**
```
public class MensajeEmail implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando Email a " + destinatario + ": " + contenido);
    }
}

public class MensajeSMS implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando SMS a " + destinatario + ": " + contenido);
    }
}
```
- **Creator**
```
public abstract class MensajeFactory {
    // M√©todo Factory
    public abstract Mensaje crearMensaje();
}
```
- **ConcreteCreator**
```
public class EmailFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeEmail();
    }
}

public class SMSFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeSMS();
    }
}
```
- **Cliente**
```
public class Main {
    public static void main(String[] args) {
        MensajeFactory factory = new EmailFactory();  // puede cambiarse por SMSFactory
        Mensaje mensaje = factory.crearMensaje();
        mensaje.enviar("ana@example.com", "Hola Ana!");
    }
}
```


## Abstract Factory
**Aplicabilidad**
- Cuando un sistema deba ser independiente de c√≥mo se crean, componen y representan sus productos.
- Cuando un sistema deba ser configurado con una familia de productos de entre varias.
- Cuando una familia de objetos producto relacionados est√© dise√±ada para ser usada conjuntamente, y sea necesario hacer cumplir esta restricci√≥n.
- Cuando se quiera proporcionar una biblioteca de clases de productos, y solo se quiera revelar sus interfaces, no sus implementaciones

**Estructura**

![image](https://github.com/user-attachments/assets/4e57c3d4-0f34-45d9-84e6-01ea069573e8)

- Los **AbstractProduct** declaran interfaces para un grupo de productos diferentes pero relacionados que forman una familia de productos
- Los **Products**, productos concretos, son las distintas implementaciones de productos abstractos agrupados por variantes. Cada producto abstracto debe implementarse en todas las variantes dadas
- La **AbstractFactory** declara un grupo de metodos para crear cada uno de los productos abstractos
- Las **ConcreteFactory** implementan los m√©todos de creaci√≥n de la f√°brica abstracta. Cada f√°brica concreta se corresponde con una variante espec√≠fica de los productos y crea tan solo dichas variantes de los productos.
 -El **Cliente** puede funcionar con cualquier variante f√°brica/producto concreta, siempre y cuando se comunique con sus objetos a trav√©s de interfaces abstractas.
  
### Ejemplo 1
**Situacion**: Una empresa est√° desarrollando una aplicaci√≥n de interfaz gr√°fica que debe poder funcionar en Windows y en Mac. Al principio, todo fue hecho para Windows, y se usaban botones, men√∫s y ventanas espec√≠ficas de Windows.

Cuando se quiso soportar Mac, el equipo se dio cuenta de que el c√≥digo estaba lleno de condicionales como if (sistema == WINDOWS) y if (sistema == MAC), para decidir qu√© componente gr√°fico usar.
Esto hizo el c√≥digo dif√≠cil de mantener, muy repetitivo, y fr√°gil ante cambios.

El problema era que todo el sistema estaba acoplado a familias de objetos concretos: botones, men√∫s, ventanas espec√≠ficas de cada sistema operativo.

**Solucion**: Definir una familia de objetos relacionados (por ejemplo, todos los componentes gr√°ficos de Windows o de Mac) mediante una interfaz com√∫n, y delegar la creaci√≥n de todos ellos a una f√°brica abstracta. As√≠ se pueden crear objetos sin que el cliente tenga que saber qu√© sistema operativo se est√° usando.

**En codigo**: interfaz gr√°fica con dos temas: TemaClaro y TemaOscuro. Cada tema tiene su Bot√≥n y su Men√∫.
- **AbstractProduct**
```
public interface Boton {
    void dibujar();
}

public interface Menu {
    void desplegar();
}
```
- **Product**
```
public class BotonClaro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot√≥n claro");
    }
}

public class BotonOscuro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot√≥n oscuro");
    }
}

public class MenuClaro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men√∫ claro");
    }
}

public class MenuOscuro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men√∫ oscuro");
    }
}
```
- **AbstractFactory**
```
public interface GUIFactory {
    Boton crearBoton();
    Menu crearMenu();
}
```
- **ConcreteFactory**
```
public class TemaClaroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonClaro();
    }

    public Menu crearMenu() {
        return new MenuClaro();
    }
}

public class TemaOscuroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonOscuro();
    }

    public Menu crearMenu() {
        return new MenuOscuro();
    }
}
```
- **Client**
```
public class Aplicacion {
    private Boton boton;
    private Menu menu;

    public Aplicacion(GUIFactory factory) {
        boton = factory.crearBoton();
        menu = factory.crearMenu();
    }

    public void mostrarUI() {
        boton.dibujar();
        menu.desplegar();
    }

    public static void main(String[] args) {
        GUIFactory factory = new TemaOscuroFactory(); // cambia por TemaClaroFactory
        Aplicacion app = new Aplicacion(factory);
        app.mostrarUI();
    }
}
```
- **Main**
```
public class Main {
    public static void main(String[] args) {
        GUIFactory factory;

        // Supongamos que detectamos tema oscuro
        factory = new TemaOscuroFactory();  // üëàüèº decide la variante

        Aplicacion app = new Aplicacion(factory);  // üëàüèº se inyecta la f√°brica
        app.dibujarUI();  // üëàüèº la app usa los productos, sin saber cu√°les
    }
}
```

## Builder
Nos permite construir objetos complejos paso a paso. El patr√≥n nos permite producir distintos tipos y representaciones de un objeto empleando el mismo c√≥digo de construcci√≥n.

**Aplicabilidad**
- Para evitar un ‚Äúconstructor telesc√≥pico‚Äù. Digamos que tenemos un constructor con diez par√°metros opcionales. Invocar a semejante bestia es poco pr√°ctico, por lo que sobrecargamos el constructor y creamos varias versiones m√°s cortas con menos par√°metros
```
class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...
```
- Cuando el objeto se puede construir de varias formas.
- Cuando es complicado de instanciar con un solo constructor largo.
- Cuando tiene muchos atributos opcionales o configurables.


**Estructura**

![image](https://github.com/user-attachments/assets/e8eb49c0-fdae-429d-9c86-88042c2d6898)

- La interfaz **Builder** declara pasos de la construccion de un producto que todos los tipos de objetos builder tienen en comun
- Los **ConcreteBuilder** son distintas implementaciones de los pasos de construccion
- Los **Product** son los objetos resultantes. Los productos construidos por distintos objetos constructores no tienen que pertenecer a la misma jerarqu√≠a de clases o interfaz.
- La clase directora **Director** define el orden en el que se invocaran los pasos de construccion. Es opcional
- El **Client** debe asociar uno de los objetos constructores con la clase directora

### Ejemplo 1
**Situaci√≥n**: Quer√©s crear reportes PDF en una app. Algunos tienen portada, otros no. Algunos tienen pie de p√°gina, otros gr√°ficos, otros resumen, etc. Si trat√°s de hacerlo todo con un constructor, queda algo horrible como: `new Reporte(true, false, true, null, "T√≠tulo", null, true, false, ...)`. </br>
Y adem√°s, si quer√©s cambiar la forma de construir un reporte, ten√©s que modificar el c√≥digo del `Reporte` mismo.

**Problema**: El constructor es inmanejable y no es claro qu√© representa cada par√°metro. Es dif√≠cil extender y mantener. Adem√°s, no pod√©s crear distintas ‚Äúversiones‚Äù del reporte sin meter muchos if.

**Soluci√≥n**: Separar el objeto que se construye (por ejemplo, Reporte) del proceso de construcci√≥n. As√≠, pod√©s tener distintos "constructores paso a paso" (Builders) que arman reportes distintos de manera m√°s clara. El patr√≥n Builder sugiere que saques el c√≥digo de construcci√≥n del objeto de su propia clase y lo coloques dentro de objetos independientes llamados constructores.

### Ejemplo 2
**Situacion**: Est√°s desarrollando una aplicaci√≥n de dise√±o de casas. Cada casa puede tener distintas configuraciones: algunas tienen paredes de ladrillo, otras de m√°rmol, unas tienen piscina, otras no, unas tienen techo de tejas, otras de vidrio, etc. A medida que el sistema creci√≥, cada casa empez√≥ a tener m√°s opciones: jard√≠n, garage, piso, ventanas, paneles solares, alarma, etc. El constructor empez√≥ a tener m√°s y m√°s par√°metros. El c√≥digo qued√≥ dif√≠cil de entender y mantener: `Casa casa = new Casa("m√°rmol", "vidrio", true, true, false, "roble", true, false, false, true);`. Y si quer√≠as construir diferentes tipos de casa (moderna, simple, lujosa), ten√≠as que meter if y switch por todos lados o duplicar c√≥digo.

**Solucion**: El patr√≥n Builder permite construir paso a paso objetos complejos como Casa, separando la l√≥gica de construcci√≥n de la estructura del objeto.

As√≠ pod√©s tener distintos "constructores" (CasaDeLujoBuilder, CasaEstandarBuilder) que implementan la misma interfaz y que saben c√≥mo construir cada tipo de casa.

Luego, un Director (como Ingeniero) usa ese builder para ensamblar la casa siguiendo un orden definido

**En codigo**
- **Product**
```
class Casa {
    String paredes;
    String techo;
    boolean piscina;

    public void mostrar() {
        System.out.println("Casa con: " + paredes + ", " + techo + ", piscina: " + piscina);
    }
}
```
- **Builder**
```
interface CasaBuilder {
    void construirParedes();
    void construirTecho();
    void construirPiscina();
    Casa obtenerResultado();
}
```
- **ConcreteBuilder**: para una casa de tipo "De Lujo"
```
class CasaDeLujoBuilder implements CasaBuilder {
    private Casa casa = new Casa();

    public void construirParedes() {
        casa.paredes = "Paredes de m√°rmol";
    }

    public void construirTecho() {
        casa.techo = "Techo de vidrio";
    }

    public void construirPiscina() {
        casa.piscina = true;
    }

    public Casa obtenerResultado() {
        return casa;
    }
}
```
- **Director**
```
class Ingeniero {
    private CasaBuilder builder;

    public Ingeniero(CasaBuilder builder) {
        this.builder = builder;
    }

    public Casa construirCasa() {
        builder.construirParedes();
        builder.construirTecho();
        builder.construirPiscina();
        return builder.obtenerResultado();
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        CasaBuilder builder = new CasaDeLujoBuilder();
        Ingeniero director = new Ingeniero(builder);

        Casa casa = director.construirCasa();
        casa.mostrar();
    }
}
```

### Builder vs Factory
![image](https://github.com/user-attachments/assets/ba6cec00-0e9d-4b06-9fff-3f3fa8ba3b3b)

## Singleton
El patr√≥n Singleton asegura que una clase tenga una √∫nica instancia en todo el sistema, y proporciona un punto de acceso global a esa instancia.

**Aplicabilidad**
- Cuando se necesita que solo exista una unica instancia de algo
- CUando se necesita compartir un recurso global

El patr√≥n Singleton resuelve dos problemas al mismo tiempo, vulnerando el *Principio de responsabilidad √∫nica*:
1. Garantizar que una clase tenga una √∫nica instancia. ¬øPor qu√© querr√≠a alguien controlar cu√°ntas instancias tiene una clase? El motivo m√°s habitual es controlar el acceso a alg√∫n recurso compartido, por ejemplo, una base de datos o un archivo.
2. Proporcionar un punto de acceso global a dicha instancia. Al igual que una variable global, el patr√≥n Singleton nos permite acceder a un objeto desde cualquier parte del programa. No obstante, tambi√©n evita que otro c√≥digo sobreescriba esa instancia.


**Estructura**

![image](https://github.com/user-attachments/assets/341462fd-a267-4b4f-8130-86d1b4f749f3)

La clase **Singleton** declara el m√©todo est√°tico obtenerInstancia que devuelve la misma instancia de su propia clase.

El constructor del Singleton debe ocultarse del c√≥digo cliente. La llamada al m√©todo obtenerInstancia debe ser la √∫nica manera de obtener el objeto de Singleton.

### Ejemplo 1
```
public class Configuracion {

    // 1. Instancia √∫nica, privada y est√°tica
    private static Configuracion instancia;

    // 2. Constructor privado
    private Configuracion() {
        System.out.println("Cargando configuraci√≥n...");
    }

    // 3. M√©todo p√∫blico de acceso (lazy + sincronizado)
    public static synchronized Configuracion getInstance() {
        if (instancia == null) {
            instancia = new Configuracion();
        }
        return instancia;
    }

    // M√©todo de ejemplo
    public void mostrar() {
        System.out.println("Configuraci√≥n en uso");
    }
}
```
Uso:
```
public class Main {
    public static void main(String[] args) {
        Configuracion c1 = Configuracion.getInstance();
        Configuracion c2 = Configuracion.getInstance();

        c1.mostrar();

        System.out.println(c1 == c2);  // true, es la misma instancia
    }
}
```

# Patrones estructurales
Son soluciones reutilizables que ayudan a resolver problemas comunes en la construcci√≥n de software al definir c√≥mo se componen las clases y objetos para crear estructuras complejas. Se enfocan en la estructura de clases y objetos, utilizando herramientas para ensamblar objetos y clases en estructuras m√°s grandes. 

Facilitan el dise√±o al identificar una forma simple de realizar relaciones entre entidades

## Decorator

## Adapter 

# Patrones de comportamiento
Son patrones que definen c√≥mo los objetos interact√∫an y se comunican entre s√≠, centr√°ndose en la asignaci√≥n de responsabilidades y la implementaci√≥n de algoritmos. Se enfoca en como las clases y objetos se comunican entre ellas.

## Null object

## State

## Strategy

## Template Method

## Interpreter

![image](https://github.com/user-attachments/assets/c6b06a9f-ef37-4085-8698-ef1e214cd1cd)

## Visitor

## Observer
