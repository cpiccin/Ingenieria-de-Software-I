# Patrones de dise√±o
**Creational patterns** provide object creation mechanisms that increase flexibility and reuse of existing code.

**Structural patterns** explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.

**Behavioral patterns** take care of effective communication and the assignment of responsibilities between objects.


# Patrones creacionales
Se enfocan en c√≥mo crear objetos, separando el proceso de creaci√≥n de su uso. Abordan el problema de c√≥mo crear objetos de manera flexible y reutilizable, proporcionando mecanismos para la creaci√≥n de objetos que no se basan en la creaci√≥n directa de objetos. 

## Factory
**Aplicabilidad**: 
- Cuando desde una clase se desee crear y usar objetos sin que la misma quede acoplada a las clases de estos.
- Cuando una clase no pueda anticipar la clase de objetos que debe crear.
- Cuando una clase quiera que sean sus subclases las que especifiquen los objetos que crea.

**Estructura**

![image](https://github.com/user-attachments/assets/01fbcbc5-c789-4062-9714-e7ea87c8b27a)

- **Product** declara la interfaz, que es comun a todos los objetos que puede producir la clase creadora y sus subclases
- Los **ConcreteProduct** son distintas implementaciones de Product
- La clase **Creator** declara el metodo factory que devuelve nuevos objetos de producto. Coincide el tipo de retorno con el tipo de la interfaz de producto
- Los **ConcreteCreators** sobreescriben el Factory Method, devolviendo un tipo diferente de producto

*Efectos deseados*: El patr√≥n sigue el Principio de Responsabilidad √önica (la creaci√≥n de los
objetos se concentra en las f√°bricas). Se disminuye el acoplamiento entre las clases. Y sigue el Principio de abierto/cerrado. Puedes incorporar nuevos tipos de productos en el programa sin descomponer el c√≥digo cliente existente.

### Ejemplo 1
**Situacion**: Una aplicaci√≥n de mensajer√≠a fue dise√±ada inicialmente solo para enviar correos electr√≥nicos. Toda la l√≥gica de env√≠o de mensajes, validaci√≥n y formato estaba escrita directamente en una clase MensajeEmail.

Los usuarios comenzaron a solicitar otros tipos de mensajes, como SMS y WhatsApp. Para agregarlos, el equipo tuvo que llenar el c√≥digo de condicionales que preguntaban por el tipo de mensaje: `"si es email, hacer esto... si es SMS, hacer esto otro..."`. Esto hizo que el sistema fuera dif√≠cil de mantener, dif√≠cil de escalar, y muy propenso a errores cada vez que se quer√≠a agregar un nuevo tipo de mensaje.

El problema central era que el c√≥digo estaba fuertemente **acoplado** a los tipos concretos de mensajes. Cada vez que se agregaba uno nuevo, era necesario modificar varias partes del sistema, violando el principio de abierto/cerrado (el c√≥digo deber√≠a estar abierto a la extensi√≥n pero cerrado a la modificaci√≥n).

**Soluci√≥n**: En vez de instanciar directamente (new MensajeEmail()), delegamos la creaci√≥n del objeto a un m√©todo f√°brica. Este m√©todo es declarado en una clase abstracta (o interfaz), y cada tipo de mensaje tendr√° su propia clase que implemente ese m√©todo, devolviendo el objeto adecuado.

**En codigo**

- **Product**
```
public interface Mensaje {
    void enviar(String destinatario, String contenido);
}
```
- **ConcreteProduct**
```
public class MensajeEmail implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando Email a " + destinatario + ": " + contenido);
    }
}

public class MensajeSMS implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando SMS a " + destinatario + ": " + contenido);
    }
}
```
- **Creator**
```
public abstract class MensajeFactory {
    // M√©todo Factory
    public abstract Mensaje crearMensaje();
}
```
- **ConcreteCreator**
```
public class EmailFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeEmail();
    }
}

public class SMSFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeSMS();
    }
}
```
- **Cliente**
```
public class Main {
    public static void main(String[] args) {
        MensajeFactory factory = new EmailFactory();  // puede cambiarse por SMSFactory
        Mensaje mensaje = factory.crearMensaje();
        mensaje.enviar("ana@example.com", "Hola Ana!");
    }
}
```


## Abstract Factory
**Aplicabilidad**
- Cuando un sistema deba ser independiente de c√≥mo se crean, componen y representan sus productos.
- Cuando un sistema deba ser configurado con una familia de productos de entre varias.
- Cuando una familia de objetos producto relacionados est√© dise√±ada para ser usada conjuntamente, y sea necesario hacer cumplir esta restricci√≥n.
- Cuando se quiera proporcionar una biblioteca de clases de productos, y solo se quiera revelar sus interfaces, no sus implementaciones

**Estructura**

![image](https://github.com/user-attachments/assets/4e57c3d4-0f34-45d9-84e6-01ea069573e8)

- Los **AbstractProduct** declaran interfaces para un grupo de productos diferentes pero relacionados que forman una familia de productos
- Los **Products**, productos concretos, son las distintas implementaciones de productos abstractos agrupados por variantes. Cada producto abstracto debe implementarse en todas las variantes dadas
- La **AbstractFactory** declara un grupo de metodos para crear cada uno de los productos abstractos
- Las **ConcreteFactory** implementan los m√©todos de creaci√≥n de la f√°brica abstracta. Cada f√°brica concreta se corresponde con una variante espec√≠fica de los productos y crea tan solo dichas variantes de los productos.
 -El **Cliente** puede funcionar con cualquier variante f√°brica/producto concreta, siempre y cuando se comunique con sus objetos a trav√©s de interfaces abstractas.
  
### Ejemplo 1
**Situacion**: Una empresa est√° desarrollando una aplicaci√≥n de interfaz gr√°fica que debe poder funcionar en Windows y en Mac. Al principio, todo fue hecho para Windows, y se usaban botones, men√∫s y ventanas espec√≠ficas de Windows.

Cuando se quiso soportar Mac, el equipo se dio cuenta de que el c√≥digo estaba lleno de condicionales como if (sistema == WINDOWS) y if (sistema == MAC), para decidir qu√© componente gr√°fico usar.
Esto hizo el c√≥digo dif√≠cil de mantener, muy repetitivo, y fr√°gil ante cambios.

El problema era que todo el sistema estaba acoplado a familias de objetos concretos: botones, men√∫s, ventanas espec√≠ficas de cada sistema operativo.

**Solucion**: Definir una familia de objetos relacionados (por ejemplo, todos los componentes gr√°ficos de Windows o de Mac) mediante una interfaz com√∫n, y delegar la creaci√≥n de todos ellos a una f√°brica abstracta. As√≠ se pueden crear objetos sin que el cliente tenga que saber qu√© sistema operativo se est√° usando.

**En codigo**: interfaz gr√°fica con dos temas: TemaClaro y TemaOscuro. Cada tema tiene su Bot√≥n y su Men√∫.
- **AbstractProduct**
```
public interface Boton {
    void dibujar();
}

public interface Menu {
    void desplegar();
}
```
- **Product**
```
public class BotonClaro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot√≥n claro");
    }
}

public class BotonOscuro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot√≥n oscuro");
    }
}

public class MenuClaro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men√∫ claro");
    }
}

public class MenuOscuro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men√∫ oscuro");
    }
}
```
- **AbstractFactory**
```
public interface GUIFactory {
    Boton crearBoton();
    Menu crearMenu();
}
```
- **ConcreteFactory**
```
public class TemaClaroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonClaro();
    }

    public Menu crearMenu() {
        return new MenuClaro();
    }
}

public class TemaOscuroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonOscuro();
    }

    public Menu crearMenu() {
        return new MenuOscuro();
    }
}
```
- **Client**
```
public class Aplicacion {
    private Boton boton;
    private Menu menu;

    public Aplicacion(GUIFactory factory) {
        boton = factory.crearBoton();
        menu = factory.crearMenu();
    }

    public void mostrarUI() {
        boton.dibujar();
        menu.desplegar();
    }

    public static void main(String[] args) {
        GUIFactory factory = new TemaOscuroFactory(); // cambia por TemaClaroFactory
        Aplicacion app = new Aplicacion(factory);
        app.mostrarUI();
    }
}
```
- **Main**
```
public class Main {
    public static void main(String[] args) {
        GUIFactory factory;

        // Supongamos que detectamos tema oscuro
        factory = new TemaOscuroFactory();  // üëàüèº decide la variante

        Aplicacion app = new Aplicacion(factory);  // üëàüèº se inyecta la f√°brica
        app.dibujarUI();  // üëàüèº la app usa los productos, sin saber cu√°les
    }
}
```

## Builder
Nos permite construir objetos complejos paso a paso. El patr√≥n nos permite producir distintos tipos y representaciones de un objeto empleando el mismo c√≥digo de construcci√≥n.

**Aplicabilidad**
- Para evitar un ‚Äúconstructor telesc√≥pico‚Äù. Digamos que tenemos un constructor con diez par√°metros opcionales. Invocar a semejante bestia es poco pr√°ctico, por lo que sobrecargamos el constructor y creamos varias versiones m√°s cortas con menos par√°metros
```
class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...
```
- Cuando el objeto se puede construir de varias formas.
- Cuando es complicado de instanciar con un solo constructor largo.
- Cuando tiene muchos atributos opcionales o configurables.


**Estructura**

![image](https://github.com/user-attachments/assets/e8eb49c0-fdae-429d-9c86-88042c2d6898)

- La interfaz **Builder** declara pasos de la construccion de un producto que todos los tipos de objetos builder tienen en comun
- Los **ConcreteBuilder** son distintas implementaciones de los pasos de construccion
- Los **Product** son los objetos resultantes. Los productos construidos por distintos objetos constructores no tienen que pertenecer a la misma jerarqu√≠a de clases o interfaz.
- La clase directora **Director** define el orden en el que se invocaran los pasos de construccion. Es opcional
- El **Client** debe asociar uno de los objetos constructores con la clase directora

### Ejemplo 1
**Situaci√≥n**: Quer√©s crear reportes PDF en una app. Algunos tienen portada, otros no. Algunos tienen pie de p√°gina, otros gr√°ficos, otros resumen, etc. Si trat√°s de hacerlo todo con un constructor, queda algo horrible como: `new Reporte(true, false, true, null, "T√≠tulo", null, true, false, ...)`. </br>
Y adem√°s, si quer√©s cambiar la forma de construir un reporte, ten√©s que modificar el c√≥digo del `Reporte` mismo.

**Problema**: El constructor es inmanejable y no es claro qu√© representa cada par√°metro. Es dif√≠cil extender y mantener. Adem√°s, no pod√©s crear distintas ‚Äúversiones‚Äù del reporte sin meter muchos if.

**Soluci√≥n**: Separar el objeto que se construye (por ejemplo, Reporte) del proceso de construcci√≥n. As√≠, pod√©s tener distintos "constructores paso a paso" (Builders) que arman reportes distintos de manera m√°s clara. El patr√≥n Builder sugiere que saques el c√≥digo de construcci√≥n del objeto de su propia clase y lo coloques dentro de objetos independientes llamados constructores.

### Ejemplo 2
**Situacion**: Est√°s desarrollando una aplicaci√≥n de dise√±o de casas. Cada casa puede tener distintas configuraciones: algunas tienen paredes de ladrillo, otras de m√°rmol, unas tienen piscina, otras no, unas tienen techo de tejas, otras de vidrio, etc. A medida que el sistema creci√≥, cada casa empez√≥ a tener m√°s opciones: jard√≠n, garage, piso, ventanas, paneles solares, alarma, etc. El constructor empez√≥ a tener m√°s y m√°s par√°metros. El c√≥digo qued√≥ dif√≠cil de entender y mantener: `Casa casa = new Casa("m√°rmol", "vidrio", true, true, false, "roble", true, false, false, true);`. Y si quer√≠as construir diferentes tipos de casa (moderna, simple, lujosa), ten√≠as que meter if y switch por todos lados o duplicar c√≥digo.

**Solucion**: El patr√≥n Builder permite construir paso a paso objetos complejos como Casa, separando la l√≥gica de construcci√≥n de la estructura del objeto.

As√≠ pod√©s tener distintos "constructores" (CasaDeLujoBuilder, CasaEstandarBuilder) que implementan la misma interfaz y que saben c√≥mo construir cada tipo de casa.

Luego, un Director (como Ingeniero) usa ese builder para ensamblar la casa siguiendo un orden definido

**En codigo**
- **Product**
```
class Casa {
    String paredes;
    String techo;
    boolean piscina;

    public void mostrar() {
        System.out.println("Casa con: " + paredes + ", " + techo + ", piscina: " + piscina);
    }
}
```
- **Builder**
```
interface CasaBuilder {
    void construirParedes();
    void construirTecho();
    void construirPiscina();
    Casa obtenerResultado();
}
```
- **ConcreteBuilder**: para una casa de tipo "De Lujo"
```
class CasaDeLujoBuilder implements CasaBuilder {
    private Casa casa = new Casa();

    public void construirParedes() {
        casa.paredes = "Paredes de m√°rmol";
    }

    public void construirTecho() {
        casa.techo = "Techo de vidrio";
    }

    public void construirPiscina() {
        casa.piscina = true;
    }

    public Casa obtenerResultado() {
        return casa;
    }
}
```
- **Director**
```
class Ingeniero {
    private CasaBuilder builder;

    public Ingeniero(CasaBuilder builder) {
        this.builder = builder;
    }

    public Casa construirCasa() {
        builder.construirParedes();
        builder.construirTecho();
        builder.construirPiscina();
        return builder.obtenerResultado();
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        CasaBuilder builder = new CasaDeLujoBuilder();
        Ingeniero director = new Ingeniero(builder);

        Casa casa = director.construirCasa();
        casa.mostrar();
    }
}
```

### Builder vs Factory
![image](https://github.com/user-attachments/assets/ba6cec00-0e9d-4b06-9fff-3f3fa8ba3b3b)

## Singleton
El patr√≥n Singleton asegura que una clase tenga una √∫nica instancia en todo el sistema, y proporciona un punto de acceso global a esa instancia.

**Aplicabilidad**
- Cuando se necesita que solo exista una unica instancia de algo
- CUando se necesita compartir un recurso global

El patr√≥n Singleton resuelve dos problemas al mismo tiempo, vulnerando el *Principio de responsabilidad √∫nica*:
1. Garantizar que una clase tenga una √∫nica instancia. ¬øPor qu√© querr√≠a alguien controlar cu√°ntas instancias tiene una clase? El motivo m√°s habitual es controlar el acceso a alg√∫n recurso compartido, por ejemplo, una base de datos o un archivo.
2. Proporcionar un punto de acceso global a dicha instancia. Al igual que una variable global, el patr√≥n Singleton nos permite acceder a un objeto desde cualquier parte del programa. No obstante, tambi√©n evita que otro c√≥digo sobreescriba esa instancia.


**Estructura**

![image](https://github.com/user-attachments/assets/341462fd-a267-4b4f-8130-86d1b4f749f3)

La clase **Singleton** declara el m√©todo est√°tico obtenerInstancia que devuelve la misma instancia de su propia clase.

El constructor del Singleton debe ocultarse del c√≥digo cliente. La llamada al m√©todo obtenerInstancia debe ser la √∫nica manera de obtener el objeto de Singleton.

### Ejemplo 1
```
public class Configuracion {

    // 1. Instancia √∫nica, privada y est√°tica
    private static Configuracion instancia;

    // 2. Constructor privado
    private Configuracion() {
        System.out.println("Cargando configuraci√≥n...");
    }

    // 3. M√©todo p√∫blico de acceso (lazy + sincronizado)
    public static synchronized Configuracion getInstance() {
        if (instancia == null) {
            instancia = new Configuracion();
        }
        return instancia;
    }

    // M√©todo de ejemplo
    public void mostrar() {
        System.out.println("Configuraci√≥n en uso");
    }
}
```
Uso:
```
public class Main {
    public static void main(String[] args) {
        Configuracion c1 = Configuracion.getInstance();
        Configuracion c2 = Configuracion.getInstance();

        c1.mostrar();

        System.out.println(c1 == c2);  // true, es la misma instancia
    }
}
```

# Patrones estructurales
Son soluciones reutilizables que ayudan a resolver problemas comunes en la construcci√≥n de software al definir c√≥mo se componen las clases y objetos para crear estructuras complejas. Se enfocan en la estructura de clases y objetos, utilizando herramientas para ensamblar objetos y clases en estructuras m√°s grandes. 

Facilitan el dise√±o al identificar una forma simple de realizar relaciones entre entidades

## Decorator
A√±ade din√°micamente nuevas responsabilidades a un objeto, proporcionando una alternativa
flexible a la herencia para extender la funcionalidad.

**Aplicabilidad**: 
- Cuando se desee a√±adir responsabilidades a objetos individuales de forma din√°mica y transparente, es decir, sin afectar a otros objetos.
- Cuando se desee que las responsabilidades puedan ser retiradas.
- Cuando la extensi√≥n mediante la herencia no es viable (a veces es posible tener un gran n√∫mero de extensiones independientes, produci√©ndose una explosi√≥n de subclases para permitir todas las combinaciones).

‚ÄúWrapper‚Äù es el sobrenombre alternativo del patr√≥n Decorator. Un *wrapper* es un objeto que puede vincularse con un objeto *objetivo*. El wrapper contiene el mismo grupo de m√©todos que el objetivo y le delega todas las solicitudes que recibe. No obstante, el wrapper puede alterar el resultado haciendo algo antes o despu√©s de pasar la solicitud al objetivo.

El patr√≥n Decorator envuelve (o ‚Äúdecora‚Äù) un objeto original en otro objeto que a√±ade o modifica la funcionalidad del primero.

**Estructura**

![image](https://github.com/user-attachments/assets/1e7fddca-ea96-4239-ab98-24df34514969)

- **Component** declara la interfaz comun tanto para wrappers como para objetos envueltos
- El **ConcreteComponent** es una clase de objetos que seran envueltos. Define el comportamiento basico que sera alterado por los decorators
- La clase **BaseDecorator** tiene un campo que referencia un objeto envuelto. Su funci√≥n es delegar las llamadas al objeto encapsulado
- Los **ConcreteDecorator** definen comportamiento extra que se le puede agregar al componente dinamicamente. Hacen un override de los metodos del base decorator. Extienden la clase BaseDecorator y a√±aden responsabilidades extra antes o despu√©s de delegar la llamada al componente.
- El **Client** puede wrappear componentes en multiples capas de decorators

*Efectos deseados*: El patr√≥n ofrece m√°s flexibilidad que la herencia est√°tica (ofrece un enfoque para a√±adir responsabilidades que consiste en pagar solo por aquello que se necesita). El patr√≥n permite seguir el Principio de Responsabilidad √önica.


### Analogia 1
Vestir ropa es un ejemplo del uso de decoradores. Cuando tienes fr√≠o, te cubres con un su√©ter. Si sigues teniendo fr√≠o a pesar del su√©ter, puedes ponerte una chaqueta encima. Si est√° lloviendo, puedes ponerte un impermeable. Todas estas prendas ‚Äúextienden‚Äù tu comportamiento b√°sico pero no son parte de ti, y puedes quitarte f√°cilmente cualquier prenda cuando lo desees.

[https://refactoring.guru/es/design-patterns/decorator#:~:text=Vestir%20ropa%20es,cuando%20lo%20desees.]


### Ejemplo 1
**Situacion**: Una aplicaci√≥n de mensajer√≠a permite enviar mensajes de texto. Inicialmente, los mensajes son simples. Con el tiempo, se quiere permitir que los mensajes se puedan: Enviar en negrita (<b>Hola</b>); Encriptar su contenido para mayor seguridad; A√±adir otras decoraciones como emoji, marcas de tiempo, etc. Pero no todos los mensajes deben tener todas las funcionalidades. A veces se quiere enviar uno solo con negrita, a veces solo encriptado, a veces con ambas cosas, etc.

**Problema**: Si intent√°s resolver esto con herencia, tendr√≠as que crear muchas combinaciones: MensajeSimple, MensajeNegrita, MensajeEncriptado, MensajeNegritaYEncriptado, MensajeEmojiYEncriptadoYTimestamp

**Solucion**: El patr√≥n Decorator permite a√±adir funcionalidad a los objetos de forma flexible y din√°mica, sin crear nuevas subclases para cada combinaci√≥n. En lugar de usar herencia para cada caso, envolv√©s el mensaje simple en decoradores que agregan comportamiento.

**En codigo**
- **Component**
```
public interface Mensaje {
    String enviar();
}
```
- **ConcreteComponent**
```
public class MensajeSimple implements Mensaje {
    private String contenido;

    public MensajeSimple(String contenido) {
        this.contenido = contenido;
    }

    @Override
    public String enviar() {
        return contenido;
    }
}
```
- **BaseDecorator**
```
public abstract class MensajeDecorator implements Mensaje {
    protected Mensaje mensajeDecorado;

    public MensajeDecorator(Mensaje mensajeDecorado) {
        this.mensajeDecorado = mensajeDecorado;
    }

    @Override
    public String enviar() {
        return mensajeDecorado.enviar();
    }
}
```
- **ConcreteDecorator**: decorador para negrita y otro para encriptar 
```
public class MensajeNegritaDecorator extends MensajeDecorator {

    public MensajeNegritaDecorator(Mensaje mensajeDecorado) {
        super(mensajeDecorado);
    }

    @Override
    public String enviar() {
        // Aplica formato en negrita antes de enviar
        return "<b>" + super.enviar() + "</b>";
    }
}

public class MensajeEncriptadoDecorator extends MensajeDecorator {

    public MensajeEncriptadoDecorator(Mensaje mensajeDecorado) {
        super(mensajeDecorado);
    }

    private String encriptar(String texto) {
        // Algoritmo de encriptaci√≥n simple (para ejemplo)
        return new StringBuilder(texto).reverse().toString();
    }

    @Override
    public String enviar() {
        // Primero obtiene el contenido del mensaje, luego lo encripta
        return encriptar(super.enviar());
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        // Creamos un mensaje simple
        Mensaje mensaje = new MensajeSimple("Hola, mundo!");

        // Decoramos el mensaje para darle formato en negrita
        mensaje = new MensajeNegritaDecorator(mensaje);

        // Adicionalmente, lo decoramos para encriptarlo
        mensaje = new MensajeEncriptadoDecorator(mensaje);

        // Al enviar el mensaje, se aplica primero la encriptaci√≥n y luego la negrita seg√∫n el orden de los decoradores
        System.out.println(mensaje.enviar());
    }
}
```

## Adapter 
Permite la colaboraci√≥n entre objetos con interfaces incompatibles. Un *adaptador* se trata de un objeto especial que convierte la interfaz de un objeto, de forma que otro objeto pueda comprenderla.

Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podr√≠an por tener interfaces incompatibles.

**Como funciona**:
1. El adaptador obtiene una interfaz compatible con uno de los objetos existentes.
2. Utilizando esta interfaz, el objeto existente puede invocar con seguridad los m√©todos del adaptador.
3. Al recibir una llamada, el adaptador pasa la solicitud al segundo objeto, pero en un formato y orden que ese segundo objeto espera.

**Estructura**

![image](https://github.com/user-attachments/assets/5ae8a561-4217-4aad-8fb3-93fff677c410)

- El **Client** contiene la l√≥gica de negocio existente del programa.
- La **ClientInterface** describe el protocolo que deben seguir otras clases para poder colaborar con el codigo client.
- El **Service** es una clase 3rd-party o legacy que el cliente no puede usar directamente porque tiene una interfaz incompatible
- El **Adapter** es una clase que puede trabajar tanto con el cliente como con el service: implementa la interfaz del client, y wrappea el service. El adaptador recibe llamadas del cliente a traves de la interfaz del cliente y las traduce en llamadas al service wrappeado en un formato que pueda entender
- El c√≥digo cliente no se acopla a la clase adaptadora concreta siempre y cuando funcione con la clase adaptadora a trav√©s de la interfaz con el cliente. 

### Ejemplo 1
**Situacion**: Una empresa desarroll√≥ una aplicaci√≥n para gestionar pagos. Esta aplicaci√≥n usa una interfaz propia (ClientInterface) que define c√≥mo deben realizarse los pagos: pagar(double monto). Todo el c√≥digo cliente (por ejemplo, la interfaz gr√°fica, o los controladores) ya trabaja con esta interfaz.

Ahora, quieren integrar un nuevo proveedor de pagos externo (como una API bancaria), que viene con su propia clase NuevoSistemaPago, la cual tiene un m√©todo completamente distinto: realizarTransaccion(double cantidad)

**Problema**: El nuevo sistema de pagos no es compatible con la interfaz existente.
No se puede modificar ni el nuevo sistema (porque es una librer√≠a externa) ni todo el c√≥digo cliente (porque ser√≠a muy costoso y riesgoso).

**Solucion**: Se aplica el patr√≥n Adapter.
Se crea una clase AdaptadorNuevoSistemaPago que:
- Implementa la interfaz esperada por el cliente (ProcesadorPago).
- Contiene una instancia del nuevo servicio (NuevoSistemaPago).
- Traduce las llamadas de pagar(monto) en llamadas a realizarTransaccion(cantidad).

**En codigo**
- **ClientInterface** ‚Äî Interfaz que espera el cliente
```
public interface ProcesadorPago {
    void pagar(double monto);
}
```
- **Service**: Clase externa (no modificable) con una interfaz incompatible
```
public class NuevoSistemaPago {
    public void realizarTransaccion(double cantidad) {
        System.out.println("Pago procesado por el NUEVO sistema: $" + cantidad);
    }
}
```
- **Adapter**: Adapta la clase externa al cliente
```
public class AdaptadorNuevoSistemaPago implements ProcesadorPago {
    private NuevoSistemaPago nuevoSistema;

    public AdaptadorNuevoSistemaPago(NuevoSistemaPago nuevoSistema) {
        this.nuevoSistema = nuevoSistema;
    }

    @Override
    public void pagar(double monto) {
        // Adaptamos el m√©todo esperado por el cliente al del servicio real
        nuevoSistema.realizarTransaccion(monto);
    }
}
```
- **Client**
```
public class Cliente {
    private ProcesadorPago procesador;

    public Cliente(ProcesadorPago procesador) {
        this.procesador = procesador;
    }

    public void realizarPago(double monto) {
        procesador.pagar(monto);
    }
}
```
- Main
```
public class Main {
    public static void main(String[] args) {
        NuevoSistemaPago sistemaExterno = new NuevoSistemaPago();
        ProcesadorPago adaptador = new AdaptadorNuevoSistemaPago(sistemaExterno);

        Cliente cliente = new Cliente(adaptador);
        cliente.realizarPago(150.0);
    }
}
```


## Proxy
Proporciona un sustituto o representante de otro objeto para controlar el acceso a √©ste.


**Estructura**

![image](https://github.com/user-attachments/assets/aa3f2dfb-bd70-4589-bfe7-ad8ec72b661a)

- La **ServiceInterface** declara la interfaz del **Service**. El **Proxy** debe seguir esta interfaz para poder camuflarse como servicio.
- El **Service** es una clase que provee logica de negocio
- La clase **Proxy** tiene un campo que referencia a un objeto de servicio. Cuando el proxy finaliza su procesamiento, le pasa la request al objeto de servicio
- El **Client** debe funcionar con servicios y proxies a trav√©s de la misma interfaz. De este modo puedes pasar un proxy a cualquier c√≥digo que espere un objeto de servicio.

### Ejemplo 1
**Situacion**: Una empresa tiene un sistema que permite a los usuarios ver documentos confidenciales. Estos documentos est√°n representados por una clase DocumentoReal, que tiene un m√©todo ver() para acceder al contenido.

El acceso a los documentos es costoso o sensible (por ejemplo, requieren tiempo de carga, validaci√≥n, o control de acceso), y no se quiere que cualquier parte del c√≥digo pueda acceder directamente a ellos.

**Problema**: No se puede controlar qui√©n accede a DocumentoReal; Cargar el contenido del documento cada vez es lento o innecesario si el usuario no tiene permisos; No se quiere modificar DocumentoReal porque ya est√° en uso y es complejo

**Solucion**: Creamos una clase DocumentoProxy que implementa la misma interfaz que DocumentoReal (Documento); contiene una referencia al DocumentoReal; Controla el acceso al documento real. Asi, el cliente trabaja con la interfaz Documento y no sabe si est√° usando el documento real o un proxy.

**En codigo**
- **ServiceInterface**: interfaz com√∫n entre servicio y proxy
```
public interface Documento {
    void ver();
}
```
- **Service**: clase con la l√≥gica real (costosa o sensible)
```
public class DocumentoReal implements Documento {
    private String nombre;

    public DocumentoReal(String nombre) {
        this.nombre = nombre;
        cargarDesdeDisco();
    }

    private void cargarDesdeDisco() {
        System.out.println("Cargando documento " + nombre + " desde disco...");
    }

    @Override
    public void ver() {
        System.out.println("Mostrando documento: " + nombre);
    }
}
```
- **Proxy**: controla acceso y delega al servicio
```
public class DocumentoProxy implements Documento {
    private DocumentoReal documentoReal;
    private String nombre;
    private boolean tienePermiso;

    public DocumentoProxy(String nombre, boolean tienePermiso) {
        this.nombre = nombre;
        this.tienePermiso = tienePermiso;
    }

    @Override
    public void ver() {
        if (!tienePermiso) {
            System.out.println("Acceso denegado a: " + nombre);
            return;
        }

        if (documentoReal == null) {
            documentoReal = new DocumentoReal(nombre);
        }

        documentoReal.ver();
    }
}
```
- **Client**: trabaja con objetos de tipo ServiceInterface
```
public class Cliente {
    public static void main(String[] args) {
        Documento doc1 = new DocumentoProxy("contrato.pdf", true);
        Documento doc2 = new DocumentoProxy("secreto.pdf", false);

        doc1.ver(); // se permite, carga y muestra
        doc2.ver(); // acceso denegado
    }
}
```

# Patrones de comportamiento
Son patrones que definen c√≥mo los objetos interact√∫an y se comunican entre s√≠, centr√°ndose en la asignaci√≥n de responsabilidades y la implementaci√≥n de algoritmos. Se enfoca en como las clases y objetos se comunican entre ellas.


## Strategy
Permite definir una familia de algoritmos, colocar cada uno de ellos en una clase separada y hacer sus objetos intercambiables.

El patr√≥n Strategy sugiere que tomes esa clase que hace algo espec√≠fico de muchas formas diferentes y extraigas todos esos algoritmos para colocarlos en clases separadas llamadas estrategias.

**Aplicabilidad**:
- Cuando muchas clases relacionadas difieran solo en su comportamiento (las estrategias permiten configurar una clase con un determinado comportamiento de entre muchos posibles).
- Cuando una clase define muchos comportamientos, y estos se representan como m√∫ltiples sentencias condicionales en sus operaciones (en vez de tener muchos condicionales, se pueden mover las ramas de estos a su propia clase de estrategia)

**Estructura**

![image](https://github.com/user-attachments/assets/72e0d45c-8069-4353-90c2-7e46ceee436d)

- La clase **Context** mantiene una referencia a una de las **ConcreteStrategies** y se comunica con este objeto a traves de la interfaz **Strategy**
- La interfaz **Stretegy** es comun a todas las **ConcreteStrategy**. Declara un m√©todo que la clase contexto utiliza para ejecutar una estrategia.
- Las **ConcreteStrategy** implementan variaciones de un algoritmo que utiliza la clase **Context**
- La clase contexto invoca el m√©todo de ejecuci√≥n en el objeto de estrategia vinculado cada vez que necesita ejecutar el algoritmo. La clase contexto no sabe con qu√© tipo de estrategia funciona
- El **Client** crea un objeto de estrategia espec√≠fico y lo pasa a la clase contexto. La clase contexto expone un modificador set que permite a los clientes sustituir la estrategia asociada al contexto durante el tiempo de ejecuci√≥n.

*Efectos deseados*: El patr√≥n sigue el Principio de Responsabilidad √önica (organiza en clases
separadas el c√≥digo relacionado con algoritmos particulares) y el Principio Abierto/Cerrado (es
posible introducir nuevos comportamientos sin cambiar las clases de estrategia existentes o la
clase contexto). Permite aislar los detalles de implementaci√≥n de un algoritmo del c√≥digo que lo
utiliza y sustituir la herencia por composici√≥n

### Ejemplo 1
**Situacion y problema**: Ten√©s un algoritmo que var√≠a seg√∫n el contexto (por ejemplo, distintos m√©todos de pago o rutas de env√≠o), pero el c√≥digo est√° lleno de condicionales (if, switch) que dificultan el mantenimiento y la extensi√≥n.

**Solucion**: El patr√≥n Strategy permite definir una familia de algoritmos, encapsular cada uno en su propia clase e intercambiarlos f√°cilmente en tiempo de ejecuci√≥n. 

**En codigo**:
- **Strategy**
```
interface MetodoPago {
    void pagar(double monto);
}
```
- **ConcreteStrategies**
```
class PagoConTarjeta implements MetodoPago {
    public void pagar(double monto) {
        System.out.println("Pagando $" + monto + " con tarjeta.");
    }
}

class PagoConPaypal implements MetodoPago {
    public void pagar(double monto) {
        System.out.println("Pagando $" + monto + " con PayPal.");
    }
}
```
- **Context**
```
class Carrito {
    private MetodoPago metodo;

    public Carrito(MetodoPago m) {
        metodo = m;
    }

    public void setMetodo(MetodoPago m) {
        metodo = m;
    }

    public void procesarPago(double monto) {
        metodo.pagar(monto);
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        Carrito carrito = new Carrito(new PagoConTarjeta());
        carrito.procesarPago(100);

        carrito.setMetodo(new PagoConPaypal());
        carrito.procesarPago(200);
    }
}
```


## State
Permite a un objeto alterar su comportamiento cuando su estado interno cambia.

**Aplicabilidad**:
- Cuando el comportamiento de un objeto dependa de su estado y deba cambiar en tiempo de ejecuci√≥n dependiendo de ese estado.
- Cuando las operaciones tengan largas sentencias condicionales con m√∫ltiples ramas que dependen del estado del objeto. <br>
Este estado se suele representar por una o m√°s constantes enumeradas. Muchas veces son varias las operaciones que contienen esta misma estructura condicional. El patr√≥n State sugiere crear nuevas clases para todos los estados posibles de un objeto, extrayendo todos los comportamientos espec√≠ficos del estado para colocarlos dentro de esas clases.

**Estructura**

![image](https://github.com/user-attachments/assets/736939af-c11b-47e4-92ac-a6e47d1e377c)

- La clase **Context** almacena una referencia a uno de los objetos de estado concreto y le delega todo el trabajo espec√≠fico del estado. El contexto se comunica con el objeto de estado a trav√©s de la interfaz de estado. El contexto expone un modificador (setter) para pasarle un nuevo objeto de estado.
- La interfaz **State** declara los m√©todos espec√≠ficos del estado. Estos m√©todos deben tener sentido para todos los estados concretos, porque no querr√°s que uno de tus estados tenga m√©todos in√∫tiles que nunca son invocados.
- Los **ConcreteStates** proporcionan sus propias implementaciones para los m√©todos espec√≠ficos del estado.
- Tanto el estado de contexto como el concreto pueden establecer el nuevo estado del contexto y realizar la transici√≥n de estado sustituyendo el objeto de estado vinculado al contexto.

*Efectos deseados*: El patr√≥n sigue el Principio de Responsabilidad √önica (organiza en clases separadas el c√≥digo relacionado con estados particulares) y el Principio Abierto/Cerrado (es posible introducir nuevos estados sin cambiar las clases de estado existentes o la clase contexto).

### Ejemplo 1
**Situacion**:  Est√°s desarrollando una aplicaci√≥n para cajeros autom√°ticos. El cajero puede estar en diferentes estados:
- Sin tarjeta insertada.
- Tarjeta insertada pero sin PIN.
- PIN validado y listo para operar.<br>
Dependiendo del estado, las acciones del usuario (insertar tarjeta, ingresar PIN, extraer dinero) tienen comportamientos distintos.

**Problema**: Si se implementa todo en una sola clase con condicionales
```
if (estado == "TARJETA_INSERTADA") {
    // hacer esto
} else if (estado == "PIN_VALIDO") {
    // hacer otra cosa
}
```
El c√≥digo se vuelve largo, enredado y dif√≠cil de mantener, y agregar un nuevo estado requiere modificar muchas partes del c√≥digo.

**Solucion**: El patr√≥n State sugiere mover el comportamiento espec√≠fico de cada estado a clases separadas. El objeto principal (Cajero) delega su comportamiento al objeto de estado actua:
- Cada estado es una clase que implementa la misma interfaz de estado
- El contexto (Cajero) mantiene una referencia al estado actual.
- Cuando se realiza una acci√≥n (como insertarTarjeta()), el cajero simplemente delegar√° al estado actual.

**En codigo**:
- **State**
```
public interface EstadoCajero {
    void insertarTarjeta();
    void ingresarPin();
    void extraerDinero();
}
```
- **Contexto**
```
public class Cajero {
    private EstadoCajero estadoActual;

    public Cajero() {
        this.estadoActual = new EstadoSinTarjeta(this);
    }

    public void setEstado(EstadoCajero estado) {
        this.estadoActual = estado;
    }

    // M√©todos delegados
    public void insertarTarjeta() {
        estadoActual.insertarTarjeta();
    }

    public void ingresarPin() {
        estadoActual.ingresarPin();
    }

    public void extraerDinero() {
        estadoActual.extraerDinero();
    }
}
```
- **ConcreteStates**
```
class SinTarjeta implements Estado {
    Cajero cajero;

    SinTarjeta(Cajero c) { cajero = c; }

    public void insertarTarjeta() {
        System.out.println("Tarjeta insertada");
        cajero.setEstado(new ConTarjeta(cajero));
    }

    public void ingresarPin() {
        System.out.println("Inserte tarjeta primero");
    }

    public void extraer() {
        System.out.println("Sin tarjeta");
    }
}
```

```
class ConTarjeta implements Estado {
    Cajero cajero;

    ConTarjeta(Cajero c) { cajero = c; }

    public void insertarTarjeta() {
        System.out.println("Ya hay tarjeta");
    }

    public void ingresarPin() {
        System.out.println("PIN correcto");
        cajero.setEstado(new Autenticado(cajero));
    }

    public void extraer() {
        System.out.println("Ingrese PIN primero");
    }
}
```

```
class Autenticado implements Estado {
    Cajero cajero;

    Autenticado(Cajero c) { cajero = c; }

    public void insertarTarjeta() {
        System.out.println("Ya hay tarjeta");
    }

    public void ingresarPin() {
        System.out.println("PIN ya ingresado");
    }

    public void extraer() {
        System.out.println("Dinero entregado");
        cajero.setEstado(new SinTarjeta(cajero));
    }
}
```

- **Client**
```
public class Main {
    public static void main(String[] args) {
        Cajero c = new Cajero();
        c.insertarTarjeta();
        c.ingresarPin();
        c.extraer();
    }
}
```

### State vs Strategy
![image](https://github.com/user-attachments/assets/9edc8025-7048-41ce-affb-4b027f46d378)

## Template Method
Define en una operaci√≥n el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos. Permite que las subclases redefinan ciertos pasos del algoritmo sin cambiar su estructura

El patr√≥n Template Method sugiere que dividas un algoritmo en una serie de pasos, conviertas estos pasos en m√©todos y coloques una serie de llamadas a esos m√©todos dentro de un √∫nico m√©todo plantilla. Los pasos pueden ser abstractos, o contar con una implementaci√≥n por defecto. Para utilizar el algoritmo, el cliente debe aportar su propia subclase, implementar todos los pasos abstractos y sobrescribir algunos de los opcionales si es necesario

**Aplicabilidad**:
- Cuando se desee implementar en una clase las partes de un algoritmo que no cambian y dejar que sean las subclases quienes implementen el comportamiento que puede variar
- Cuando, para evitar el c√≥digo duplicado, se desee localizar en una clase com√∫n el comportamiento repetido de varias subclases.

**Estructura**

![image](https://github.com/user-attachments/assets/dc51c45c-d661-44d2-bc26-275c1cce93d1)

- La **AbstractClass** declara m√©todos que act√∫an como pasos de un algoritmo, as√≠ como el propio m√©todo plantilla que invoca estos m√©todos en un orden espec√≠fico. Los pasos pueden declararse abstractos o contar con una implementaci√≥n por defecto.
- Las **ConcreteClass** pueden sobrescribir todos los pasos, pero no el propio m√©todo plantilla.

*Efectos deseados*: El patr√≥n permite a los clientes que sobrescriban tan solo ciertas partes de un algoritmo grande, para que les afecten menos los cambios que tienen lugar en otras partes del algoritmo, y sigue el Principio DRY al colocar el c√≥digo duplicado dentro de una superclase. Los m√©todos plantilla son una t√©cnica fundamental de reutilizaci√≥n de c√≥digo

### Ejemplo 1
**Situacion**:Una aplicaci√≥n prepara bebidas calientes. Existen muchas similitudes entre preparar t√© y preparar caf√©: hervir agua, servir en taza... pero cada bebida tiene su preparaci√≥n espec√≠fica. Originalmente, cada clase implementa el proceso completo por separado,  lo que genera c√≥digo duplicado y dif√≠cil de mantener.

**Problema**: Cuando varias clases siguen el mismo flujo de pasos pero difieren en algunos detalles, es com√∫n copiar y pegar la estructura del algoritmo. Esto viola el principio DRY y vuelve costoso aplicar cambios comunes, porque hay que modificarlos en todas las clases afectadas.

**Solucion**: El patr√≥n Template Method propone definir el esqueleto del algoritmo en una clase base (abstracta), y permitir que las subclases redefinan solo los pasos que var√≠an. As√≠, se mantiene centralizado el control del flujo, pero se delega la personalizaci√≥n.

**En codigo**:
- **AbstractClass**
```
abstract class Bebida {
    public final void preparar() {
        hervirAgua();
        prepararIngrediente(); // paso variable
        servir();
    }

    void hervirAgua() {
        System.out.println("Hirviendo agua");
    }

    abstract void prepararIngrediente();

    void servir() {
        System.out.println("Sirviendo en taza");
    }
}
```
- **ConcreteClass**
```
class Cafe extends Bebida {
    void prepararIngrediente() {
        System.out.println("Agregando caf√© molido");
    }
}

class Te extends Bebida {
    void prepararIngrediente() {
        System.out.println("Agregando saquito de t√©");
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        Bebida cafe = new Cafe();
        cafe.preparar();

        Bebida te = new Te();
        te.preparar();
    }
}
```

## Interpreter
El patr√≥n Interpreter define una forma de evaluar sentencias de un lenguaje. Para ello, modela una gram√°tica usando una jerarqu√≠a de clases, donde cada clase representa un s√≠mbolo de la gram√°tica y sabe c√≥mo interpretarse a s√≠ misma.

En esencia, este patr√≥n permite interpretar o evaluar expresiones siguiendo reglas definidas de forma flexible y extensible.

## Visitor
Representa una operaci√≥n sobre los elementos de una estructura de objetos. Permite definir una nueva operaci√≥n sin cambiar las clases de los elementos sobre los que opera.

El patr√≥n Visitor sugiere que coloques el nuevo comportamiento en una clase separada llamada visitante, en lugar de intentar integrarlo dentro de clases existentes. El objeto que originalmente ten√≠a que realizar el comportamiento se pasa ahora a uno de los m√©todos del visitante como argumento, de modo que el m√©todo accede a toda la informaci√≥n necesaria contenida dentro del objeto.

Se utiliza una t√©cnica llamada **Double Dispatch**, que ayuda a ejecutar el m√©todo adecuado sobre un objeto sin complicados condicionales. En lugar de permitir al cliente seleccionar una versi√≥n adecuada del m√©todo a llamar, ¬øqu√© tal si delegamos esta opci√≥n a los objetos que pasamos al visitante como argumento? Como estos objetos conocen sus propias clases, podr√°n elegir un m√©todo adecuado en el visitante m√°s f√°cilmente. ‚ÄúAceptan‚Äù un visitante y le dicen qu√© m√©todo visitante debe ejecutarse.

**Aplicabilidad**: 
- Cuando una estructura de objetos contiene muchas clases de objetos con diferentes interfaces, y se quiere realizar operaciones sobre esos elementos que dependen de su clase concreta.
- Cuando se necesita realizar muchas operaciones distintas y no relacionadas sobre objetos de una estructura de objetos, y se quiere evitar ‚Äúcontaminar‚Äù sus clases con dichas operaciones.
- Cuando las clases que definen la estructura de objetos rara vez cambian, pero se desea definir nuevas operaciones sobre la estructura.

**Estructura**

![image](https://github.com/user-attachments/assets/4ccfc93b-533a-4035-b78f-b5538b3e3d58)

- La interfaz **Visitor** declara metodos visitantes que pueden tomar elementos concretos de una estructura de objetos como argumentos
- Cada **ConcreteVisitor** implementa varias versiones de los mismos comportamientos,  personalizadas para las distintas clases de **ConcreteElement**
- La interfaz **Element** declara un metodo para "aceptar" visitantes. Este m√©todo deber√° contar con un par√°metro declarado con el tipo de la interfaz visitante
- Cada **ConcreteElement** implementara el metodo de aceptacion (accept). El prop√≥sito de este m√©todo es redirigir la llamada al m√©todo adecuado del visitante correspondiente a la clase de elemento actual

*Efectos deseados*: El patr√≥n sigue el Principio de Responsabilidad √önica (es posible tomar varias versiones del mismo comportamiento y ponerlas en la misma clase) y el Principio Abierto/Cerrado (introducir un nuevo comportamiento que puede funcionar con objetos de clases diferentes sin cambiar esas clases).

### Ejemplo 1
**Situacion**: Ten√©s una jerarqu√≠a de clases (Circulo, Cuadrado, Tri√°ngulo) que representan diferentes figuras geom√©tricas. Est√°n bien encapsuladas y cada una tiene sus propios datos (como radio o lados).

Un d√≠a, necesit√°s calcular el √°rea de cada figura. Otro d√≠a, necesit√°s generar una versi√≥n en texto de cada figura. Despu√©s quer√©s guardar cada figura en disco.

Agregar estas operaciones directamente dentro de las clases har√≠a que esas clases cambien constantemente. Y si las clases son parte de una librer√≠a que no pod√©s modificar, se vuelve peor a√∫n.

**Problema**: Quer√©s realizar m√∫ltiples operaciones sobre objetos de una jerarqu√≠a, pero no quer√©s (o no pod√©s) modificar las clases de esos objetos cada vez que agreg√°s una nueva operaci√≥n. Adem√°s, estas operaciones pueden depender del tipo concreto del objeto (ej: calcular el √°rea de un C√≠rculo no es igual que en un Cuadrado).

**Solucion**: El patr√≥n Visitor permite separar las operaciones de los objetos sobre los que operan. Para ello, cada clase de objeto acepta un "visitante" que tiene m√©todos especializados para operar con cada tipo de objeto.

**En codigo**
- **Element**
```
interface Figura {
    void aceptar(Visitante visitante);
}
```
- **ConcreteElement**
```
class Circulo implements Figura {
    int radio;

    public Circulo(int radio) {
        this.radio = radio;
    }

    public void aceptar(Visitante visitante) {
        visitante.visitar(this);
    }
}

class Cuadrado implements Figura {
    int lado;

    public Cuadrado(int lado) {
        this.lado = lado;
    }

    public void aceptar(Visitante visitante) {
        visitante.visitar(this);
    }
}
```
- **Visitor**
```
interface Visitante {
    void visitar(Circulo c);
    void visitar(Cuadrado s);
}
```
- **ConcreteVisitor**
```
class AreaVisitante implements Visitante {
    public void visitar(Circulo c) {
        System.out.println("√Årea del c√≠rculo: " + (Math.PI * c.radio * c.radio));
    }

    public void visitar(Cuadrado s) {
        System.out.println("√Årea del cuadrado: " + (s.lado * s.lado));
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        Figura[] figuras = {
            new Circulo(5),
            new Cuadrado(4)
        };

        Visitante visitante = new AreaVisitante();

        for (Figura figura : figuras) {
            figura.aceptar(visitante);
        }
    }
}
```

Como funciona
```
Cliente:
    figura.aceptar(visitante)
        ‚Üì
Circulo:
    visitante.visitar(this)
        ‚Üì
AreaVisitante:
    visitar(Circulo c) ‚Üí l√≥gica de c√°lculo de √°rea
```
El visitor se entera a que metodo ir porque se le pasa el this en visitante.visitar(**this**)

## Observer

## Null object
