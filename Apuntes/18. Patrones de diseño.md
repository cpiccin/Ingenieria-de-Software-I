# Patrones de dise√±o
**Creational patterns** provide object creation mechanisms that increase flexibility and reuse of existing code.

**Structural patterns** explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.

**Behavioral patterns** take care of effective communication and the assignment of responsibilities between objects.


# Patrones creacionales
Se enfocan en c√≥mo crear objetos, separando el proceso de creaci√≥n de su uso. Abordan el problema de c√≥mo crear objetos de manera flexible y reutilizable, proporcionando mecanismos para la creaci√≥n de objetos que no se basan en la creaci√≥n directa de objetos. 

## Factory
**Aplicabilidad**: 
- Cuando desde una clase se desee crear y usar objetos sin que la misma quede acoplada a las clases de estos.
- Cuando una clase no pueda anticipar la clase de objetos que debe crear.
- Cuando una clase quiera que sean sus subclases las que especifiquen los objetos que crea.

**Estructura**

![image](https://github.com/user-attachments/assets/01fbcbc5-c789-4062-9714-e7ea87c8b27a)

- **Product** declara la interfaz, que es comun a todos los objetos que puede producir la clase creadora y sus subclases
- Los **ConcreteProduct** son distintas implementaciones de Product
- La clase **Creator** declara el metodo factory que devuelve nuevos objetos de producto. Coincide el tipo de retorno con el tipo de la interfaz de producto
- Los **ConcreteCreators** sobreescriben el Factory Method, devolviendo un tipo diferente de producto

*Efectos deseados*: El patr√≥n sigue el Principio de Responsabilidad √önica (la creaci√≥n de los
objetos se concentra en las f√°bricas). Se disminuye el acoplamiento entre las clases. Y sigue el Principio de abierto/cerrado. Puedes incorporar nuevos tipos de productos en el programa sin descomponer el c√≥digo cliente existente.

### Ejemplo 1
**Situacion**: Una aplicaci√≥n de mensajer√≠a fue dise√±ada inicialmente solo para enviar correos electr√≥nicos. Toda la l√≥gica de env√≠o de mensajes, validaci√≥n y formato estaba escrita directamente en una clase MensajeEmail.

Los usuarios comenzaron a solicitar otros tipos de mensajes, como SMS y WhatsApp. Para agregarlos, el equipo tuvo que llenar el c√≥digo de condicionales que preguntaban por el tipo de mensaje: `"si es email, hacer esto... si es SMS, hacer esto otro..."`. Esto hizo que el sistema fuera dif√≠cil de mantener, dif√≠cil de escalar, y muy propenso a errores cada vez que se quer√≠a agregar un nuevo tipo de mensaje.

El problema central era que el c√≥digo estaba fuertemente **acoplado** a los tipos concretos de mensajes. Cada vez que se agregaba uno nuevo, era necesario modificar varias partes del sistema, violando el principio de abierto/cerrado (el c√≥digo deber√≠a estar abierto a la extensi√≥n pero cerrado a la modificaci√≥n).

**Soluci√≥n**: En vez de instanciar directamente (new MensajeEmail()), delegamos la creaci√≥n del objeto a un m√©todo f√°brica. Este m√©todo es declarado en una clase abstracta (o interfaz), y cada tipo de mensaje tendr√° su propia clase que implemente ese m√©todo, devolviendo el objeto adecuado.

**En codigo**

- **Product**
```
public interface Mensaje {
    void enviar(String destinatario, String contenido);
}
```
- **ConcreteProduct**
```
public class MensajeEmail implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando Email a " + destinatario + ": " + contenido);
    }
}

public class MensajeSMS implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando SMS a " + destinatario + ": " + contenido);
    }
}
```
- **Creator**
```
public abstract class MensajeFactory {
    // M√©todo Factory
    public abstract Mensaje crearMensaje();
}
```
- **ConcreteCreator**
```
public class EmailFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeEmail();
    }
}

public class SMSFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeSMS();
    }
}
```
- **Cliente**
```
public class Main {
    public static void main(String[] args) {
        MensajeFactory factory = new EmailFactory();  // puede cambiarse por SMSFactory
        Mensaje mensaje = factory.crearMensaje();
        mensaje.enviar("ana@example.com", "Hola Ana!");
    }
}
```


## Abstract Factory
**Aplicabilidad**
- Cuando un sistema deba ser independiente de c√≥mo se crean, componen y representan sus productos.
- Cuando un sistema deba ser configurado con una familia de productos de entre varias.
- Cuando una familia de objetos producto relacionados est√© dise√±ada para ser usada conjuntamente, y sea necesario hacer cumplir esta restricci√≥n.
- Cuando se quiera proporcionar una biblioteca de clases de productos, y solo se quiera revelar sus interfaces, no sus implementaciones

**Estructura**

![image](https://github.com/user-attachments/assets/4e57c3d4-0f34-45d9-84e6-01ea069573e8)

- Los **AbstractProduct** declaran interfaces para un grupo de productos diferentes pero relacionados que forman una familia de productos
- Los **Products**, productos concretos, son las distintas implementaciones de productos abstractos agrupados por variantes. Cada producto abstracto debe implementarse en todas las variantes dadas
- La **AbstractFactory** declara un grupo de metodos para crear cada uno de los productos abstractos
- Las **ConcreteFactory** implementan los m√©todos de creaci√≥n de la f√°brica abstracta. Cada f√°brica concreta se corresponde con una variante espec√≠fica de los productos y crea tan solo dichas variantes de los productos.
 -El **Cliente** puede funcionar con cualquier variante f√°brica/producto concreta, siempre y cuando se comunique con sus objetos a trav√©s de interfaces abstractas.
  
### Ejemplo 1
**Situacion**: Una empresa est√° desarrollando una aplicaci√≥n de interfaz gr√°fica que debe poder funcionar en Windows y en Mac. Al principio, todo fue hecho para Windows, y se usaban botones, men√∫s y ventanas espec√≠ficas de Windows.

Cuando se quiso soportar Mac, el equipo se dio cuenta de que el c√≥digo estaba lleno de condicionales como if (sistema == WINDOWS) y if (sistema == MAC), para decidir qu√© componente gr√°fico usar.
Esto hizo el c√≥digo dif√≠cil de mantener, muy repetitivo, y fr√°gil ante cambios.

El problema era que todo el sistema estaba acoplado a familias de objetos concretos: botones, men√∫s, ventanas espec√≠ficas de cada sistema operativo.

**Solucion**: Definir una familia de objetos relacionados (por ejemplo, todos los componentes gr√°ficos de Windows o de Mac) mediante una interfaz com√∫n, y delegar la creaci√≥n de todos ellos a una f√°brica abstracta. As√≠ se pueden crear objetos sin que el cliente tenga que saber qu√© sistema operativo se est√° usando.

**En codigo**: interfaz gr√°fica con dos temas: TemaClaro y TemaOscuro. Cada tema tiene su Bot√≥n y su Men√∫.
- **AbstractProduct**
```
public interface Boton {
    void dibujar();
}

public interface Menu {
    void desplegar();
}
```
- **Product**
```
public class BotonClaro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot√≥n claro");
    }
}

public class BotonOscuro implements Boton {
    public void dibujar() {
        System.out.println("Dibujando bot√≥n oscuro");
    }
}

public class MenuClaro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men√∫ claro");
    }
}

public class MenuOscuro implements Menu {
    public void desplegar() {
        System.out.println("Mostrando men√∫ oscuro");
    }
}
```
- **AbstractFactory**
```
public interface GUIFactory {
    Boton crearBoton();
    Menu crearMenu();
}
```
- **ConcreteFactory**
```
public class TemaClaroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonClaro();
    }

    public Menu crearMenu() {
        return new MenuClaro();
    }
}

public class TemaOscuroFactory implements GUIFactory {
    public Boton crearBoton() {
        return new BotonOscuro();
    }

    public Menu crearMenu() {
        return new MenuOscuro();
    }
}
```
- **Client**
```
public class Aplicacion {
    private Boton boton;
    private Menu menu;

    public Aplicacion(GUIFactory factory) {
        boton = factory.crearBoton();
        menu = factory.crearMenu();
    }

    public void mostrarUI() {
        boton.dibujar();
        menu.desplegar();
    }

    public static void main(String[] args) {
        GUIFactory factory = new TemaOscuroFactory(); // cambia por TemaClaroFactory
        Aplicacion app = new Aplicacion(factory);
        app.mostrarUI();
    }
}
```
- **Main**
```
public class Main {
    public static void main(String[] args) {
        GUIFactory factory;

        // Supongamos que detectamos tema oscuro
        factory = new TemaOscuroFactory();  // üëàüèº decide la variante

        Aplicacion app = new Aplicacion(factory);  // üëàüèº se inyecta la f√°brica
        app.dibujarUI();  // üëàüèº la app usa los productos, sin saber cu√°les
    }
}
```

## Builder
Nos permite construir objetos complejos paso a paso. El patr√≥n nos permite producir distintos tipos y representaciones de un objeto empleando el mismo c√≥digo de construcci√≥n.

**Aplicabilidad**
- Para evitar un ‚Äúconstructor telesc√≥pico‚Äù. Digamos que tenemos un constructor con diez par√°metros opcionales. Invocar a semejante bestia es poco pr√°ctico, por lo que sobrecargamos el constructor y creamos varias versiones m√°s cortas con menos par√°metros
```
class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...
```
- Cuando el objeto se puede construir de varias formas.
- Cuando es complicado de instanciar con un solo constructor largo.
- Cuando tiene muchos atributos opcionales o configurables.


**Estructura**

![image](https://github.com/user-attachments/assets/e8eb49c0-fdae-429d-9c86-88042c2d6898)

- La interfaz **Builder** declara pasos de la construccion de un producto que todos los tipos de objetos builder tienen en comun
- Los **ConcreteBuilder** son distintas implementaciones de los pasos de construccion
- Los **Product** son los objetos resultantes. Los productos construidos por distintos objetos constructores no tienen que pertenecer a la misma jerarqu√≠a de clases o interfaz.
- La clase directora **Director** define el orden en el que se invocaran los pasos de construccion. Es opcional
- El **Client** debe asociar uno de los objetos constructores con la clase directora

### Ejemplo 1
**Situaci√≥n**: Quer√©s crear reportes PDF en una app. Algunos tienen portada, otros no. Algunos tienen pie de p√°gina, otros gr√°ficos, otros resumen, etc. Si trat√°s de hacerlo todo con un constructor, queda algo horrible como: `new Reporte(true, false, true, null, "T√≠tulo", null, true, false, ...)`. </br>
Y adem√°s, si quer√©s cambiar la forma de construir un reporte, ten√©s que modificar el c√≥digo del `Reporte` mismo.

**Problema**: El constructor es inmanejable y no es claro qu√© representa cada par√°metro. Es dif√≠cil extender y mantener. Adem√°s, no pod√©s crear distintas ‚Äúversiones‚Äù del reporte sin meter muchos if.

**Soluci√≥n**: Separar el objeto que se construye (por ejemplo, Reporte) del proceso de construcci√≥n. As√≠, pod√©s tener distintos "constructores paso a paso" (Builders) que arman reportes distintos de manera m√°s clara. El patr√≥n Builder sugiere que saques el c√≥digo de construcci√≥n del objeto de su propia clase y lo coloques dentro de objetos independientes llamados constructores.

### Ejemplo 2
**Situacion**: Est√°s desarrollando una aplicaci√≥n de dise√±o de casas. Cada casa puede tener distintas configuraciones: algunas tienen paredes de ladrillo, otras de m√°rmol, unas tienen piscina, otras no, unas tienen techo de tejas, otras de vidrio, etc. A medida que el sistema creci√≥, cada casa empez√≥ a tener m√°s opciones: jard√≠n, garage, piso, ventanas, paneles solares, alarma, etc. El constructor empez√≥ a tener m√°s y m√°s par√°metros. El c√≥digo qued√≥ dif√≠cil de entender y mantener: `Casa casa = new Casa("m√°rmol", "vidrio", true, true, false, "roble", true, false, false, true);`. Y si quer√≠as construir diferentes tipos de casa (moderna, simple, lujosa), ten√≠as que meter if y switch por todos lados o duplicar c√≥digo.

**Solucion**: El patr√≥n Builder permite construir paso a paso objetos complejos como Casa, separando la l√≥gica de construcci√≥n de la estructura del objeto.

As√≠ pod√©s tener distintos "constructores" (CasaDeLujoBuilder, CasaEstandarBuilder) que implementan la misma interfaz y que saben c√≥mo construir cada tipo de casa.

Luego, un Director (como Ingeniero) usa ese builder para ensamblar la casa siguiendo un orden definido

**En codigo**
- **Product**
```
class Casa {
    String paredes;
    String techo;
    boolean piscina;

    public void mostrar() {
        System.out.println("Casa con: " + paredes + ", " + techo + ", piscina: " + piscina);
    }
}
```
- **Builder**
```
interface CasaBuilder {
    void construirParedes();
    void construirTecho();
    void construirPiscina();
    Casa obtenerResultado();
}
```
- **ConcreteBuilder**: para una casa de tipo "De Lujo"
```
class CasaDeLujoBuilder implements CasaBuilder {
    private Casa casa = new Casa();

    public void construirParedes() {
        casa.paredes = "Paredes de m√°rmol";
    }

    public void construirTecho() {
        casa.techo = "Techo de vidrio";
    }

    public void construirPiscina() {
        casa.piscina = true;
    }

    public Casa obtenerResultado() {
        return casa;
    }
}
```
- **Director**
```
class Ingeniero {
    private CasaBuilder builder;

    public Ingeniero(CasaBuilder builder) {
        this.builder = builder;
    }

    public Casa construirCasa() {
        builder.construirParedes();
        builder.construirTecho();
        builder.construirPiscina();
        return builder.obtenerResultado();
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        CasaBuilder builder = new CasaDeLujoBuilder();
        Ingeniero director = new Ingeniero(builder);

        Casa casa = director.construirCasa();
        casa.mostrar();
    }
}
```

### Builder vs Factory
![image](https://github.com/user-attachments/assets/ba6cec00-0e9d-4b06-9fff-3f3fa8ba3b3b)

## Singleton
El patr√≥n Singleton asegura que una clase tenga una √∫nica instancia en todo el sistema, y proporciona un punto de acceso global a esa instancia.

**Aplicabilidad**
- Cuando se necesita que solo exista una unica instancia de algo
- CUando se necesita compartir un recurso global

El patr√≥n Singleton resuelve dos problemas al mismo tiempo, vulnerando el *Principio de responsabilidad √∫nica*:
1. Garantizar que una clase tenga una √∫nica instancia. ¬øPor qu√© querr√≠a alguien controlar cu√°ntas instancias tiene una clase? El motivo m√°s habitual es controlar el acceso a alg√∫n recurso compartido, por ejemplo, una base de datos o un archivo.
2. Proporcionar un punto de acceso global a dicha instancia. Al igual que una variable global, el patr√≥n Singleton nos permite acceder a un objeto desde cualquier parte del programa. No obstante, tambi√©n evita que otro c√≥digo sobreescriba esa instancia.


**Estructura**

![image](https://github.com/user-attachments/assets/341462fd-a267-4b4f-8130-86d1b4f749f3)

La clase **Singleton** declara el m√©todo est√°tico obtenerInstancia que devuelve la misma instancia de su propia clase.

El constructor del Singleton debe ocultarse del c√≥digo cliente. La llamada al m√©todo obtenerInstancia debe ser la √∫nica manera de obtener el objeto de Singleton.

### Ejemplo 1
```
public class Configuracion {

    // 1. Instancia √∫nica, privada y est√°tica
    private static Configuracion instancia;

    // 2. Constructor privado
    private Configuracion() {
        System.out.println("Cargando configuraci√≥n...");
    }

    // 3. M√©todo p√∫blico de acceso (lazy + sincronizado)
    public static synchronized Configuracion getInstance() {
        if (instancia == null) {
            instancia = new Configuracion();
        }
        return instancia;
    }

    // M√©todo de ejemplo
    public void mostrar() {
        System.out.println("Configuraci√≥n en uso");
    }
}
```
Uso:
```
public class Main {
    public static void main(String[] args) {
        Configuracion c1 = Configuracion.getInstance();
        Configuracion c2 = Configuracion.getInstance();

        c1.mostrar();

        System.out.println(c1 == c2);  // true, es la misma instancia
    }
}
```

# Patrones estructurales
Son soluciones reutilizables que ayudan a resolver problemas comunes en la construcci√≥n de software al definir c√≥mo se componen las clases y objetos para crear estructuras complejas. Se enfocan en la estructura de clases y objetos, utilizando herramientas para ensamblar objetos y clases en estructuras m√°s grandes. 

Facilitan el dise√±o al identificar una forma simple de realizar relaciones entre entidades

## Decorator
A√±ade din√°micamente nuevas responsabilidades a un objeto, proporcionando una alternativa
flexible a la herencia para extender la funcionalidad.

**Aplicabilidad**: 
- Cuando se desee a√±adir responsabilidades a objetos individuales de forma din√°mica y transparente, es decir, sin afectar a otros objetos.
- Cuando se desee que las responsabilidades puedan ser retiradas.
- Cuando la extensi√≥n mediante la herencia no es viable (a veces es posible tener un gran n√∫mero de extensiones independientes, produci√©ndose una explosi√≥n de subclases para permitir todas las combinaciones).

‚ÄúWrapper‚Äù es el sobrenombre alternativo del patr√≥n Decorator. Un *wrapper* es un objeto que puede vincularse con un objeto *objetivo*. El wrapper contiene el mismo grupo de m√©todos que el objetivo y le delega todas las solicitudes que recibe. No obstante, el wrapper puede alterar el resultado haciendo algo antes o despu√©s de pasar la solicitud al objetivo.

El patr√≥n Decorator envuelve (o ‚Äúdecora‚Äù) un objeto original en otro objeto que a√±ade o modifica la funcionalidad del primero.

**Estructura**

![image](https://github.com/user-attachments/assets/1e7fddca-ea96-4239-ab98-24df34514969)

- **Component** declara la interfaz comun tanto para wrappers como para objetos envueltos
- El **ConcreteComponent** es una clase de objetos que seran envueltos. Define el comportamiento basico que sera alterado por los decorators
- La clase **BaseDecorator** tiene un campo que referencia un objeto envuelto. Su funci√≥n es delegar las llamadas al objeto encapsulado
- Los **ConcreteDecorator** definen comportamiento extra que se le puede agregar al componente dinamicamente. Hacen un override de los metodos del base decorator. Extienden la clase BaseDecorator y a√±aden responsabilidades extra antes o despu√©s de delegar la llamada al componente.
- El **Client** puede wrappear componentes en multiples capas de decorators

*Efectos deseados*: El patr√≥n ofrece m√°s flexibilidad que la herencia est√°tica (ofrece un enfoque para a√±adir responsabilidades que consiste en pagar solo por aquello que se necesita). El patr√≥n permite seguir el Principio de Responsabilidad √önica.


### Analogia 1
Vestir ropa es un ejemplo del uso de decoradores. Cuando tienes fr√≠o, te cubres con un su√©ter. Si sigues teniendo fr√≠o a pesar del su√©ter, puedes ponerte una chaqueta encima. Si est√° lloviendo, puedes ponerte un impermeable. Todas estas prendas ‚Äúextienden‚Äù tu comportamiento b√°sico pero no son parte de ti, y puedes quitarte f√°cilmente cualquier prenda cuando lo desees.

[https://refactoring.guru/es/design-patterns/decorator#:~:text=Vestir%20ropa%20es,cuando%20lo%20desees.]


### Ejemplo 1
**Situacion**: Una aplicaci√≥n de mensajer√≠a permite enviar mensajes de texto. Inicialmente, los mensajes son simples. Con el tiempo, se quiere permitir que los mensajes se puedan: Enviar en negrita (<b>Hola</b>); Encriptar su contenido para mayor seguridad; A√±adir otras decoraciones como emoji, marcas de tiempo, etc. Pero no todos los mensajes deben tener todas las funcionalidades. A veces se quiere enviar uno solo con negrita, a veces solo encriptado, a veces con ambas cosas, etc.

**Problema**: Si intent√°s resolver esto con herencia, tendr√≠as que crear muchas combinaciones: MensajeSimple, MensajeNegrita, MensajeEncriptado, MensajeNegritaYEncriptado, MensajeEmojiYEncriptadoYTimestamp

**Solucion**: El patr√≥n Decorator permite a√±adir funcionalidad a los objetos de forma flexible y din√°mica, sin crear nuevas subclases para cada combinaci√≥n. En lugar de usar herencia para cada caso, envolv√©s el mensaje simple en decoradores que agregan comportamiento.

**En codigo**
- **Component**
```
public interface Mensaje {
    String enviar();
}
```
- **ConcreteComponent**
```
public class MensajeSimple implements Mensaje {
    private String contenido;

    public MensajeSimple(String contenido) {
        this.contenido = contenido;
    }

    @Override
    public String enviar() {
        return contenido;
    }
}
```
- **BaseDecorator**
```
public abstract class MensajeDecorator implements Mensaje {
    protected Mensaje mensajeDecorado;

    public MensajeDecorator(Mensaje mensajeDecorado) {
        this.mensajeDecorado = mensajeDecorado;
    }

    @Override
    public String enviar() {
        return mensajeDecorado.enviar();
    }
}
```
- **ConcreteDecorator**: decorador para negrita y otro para encriptar 
```
public class MensajeNegritaDecorator extends MensajeDecorator {

    public MensajeNegritaDecorator(Mensaje mensajeDecorado) {
        super(mensajeDecorado);
    }

    @Override
    public String enviar() {
        // Aplica formato en negrita antes de enviar
        return "<b>" + super.enviar() + "</b>";
    }
}

public class MensajeEncriptadoDecorator extends MensajeDecorator {

    public MensajeEncriptadoDecorator(Mensaje mensajeDecorado) {
        super(mensajeDecorado);
    }

    private String encriptar(String texto) {
        // Algoritmo de encriptaci√≥n simple (para ejemplo)
        return new StringBuilder(texto).reverse().toString();
    }

    @Override
    public String enviar() {
        // Primero obtiene el contenido del mensaje, luego lo encripta
        return encriptar(super.enviar());
    }
}
```
- **Client**
```
public class Main {
    public static void main(String[] args) {
        // Creamos un mensaje simple
        Mensaje mensaje = new MensajeSimple("Hola, mundo!");

        // Decoramos el mensaje para darle formato en negrita
        mensaje = new MensajeNegritaDecorator(mensaje);

        // Adicionalmente, lo decoramos para encriptarlo
        mensaje = new MensajeEncriptadoDecorator(mensaje);

        // Al enviar el mensaje, se aplica primero la encriptaci√≥n y luego la negrita seg√∫n el orden de los decoradores
        System.out.println(mensaje.enviar());
    }
}
```

## Adapter 
Permite la colaboraci√≥n entre objetos con interfaces incompatibles. Un *adaptador* se trata de un objeto especial que convierte la interfaz de un objeto, de forma que otro objeto pueda comprenderla.

Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podr√≠an por tener interfaces incompatibles.

**Como funciona**:
1. El adaptador obtiene una interfaz compatible con uno de los objetos existentes.
2. Utilizando esta interfaz, el objeto existente puede invocar con seguridad los m√©todos del adaptador.
3. Al recibir una llamada, el adaptador pasa la solicitud al segundo objeto, pero en un formato y orden que ese segundo objeto espera.

**Estructura**

![image](https://github.com/user-attachments/assets/5ae8a561-4217-4aad-8fb3-93fff677c410)

- El **Client** contiene la l√≥gica de negocio existente del programa.
- La **ClientInterface** describe el protocolo que deben seguir otras clases para poder colaborar con el codigo client.
- El **Service** es una clase 3rd-party o legacy que el cliente no puede usar directamente porque tiene una interfaz incompatible
- El **Adapter** es una clase que puede trabajar tanto con el cliente como con el service: implementa la interfaz del client, y wrappea el service. El adaptador recibe llamadas del cliente a traves de la interfaz del cliente y las traduce en llamadas al service wrappeado en un formato que pueda entender
- El c√≥digo cliente no se acopla a la clase adaptadora concreta siempre y cuando funcione con la clase adaptadora a trav√©s de la interfaz con el cliente. 

### Ejemplo 1
**Situacion**: Una empresa desarroll√≥ una aplicaci√≥n para gestionar pagos. Esta aplicaci√≥n usa una interfaz propia (ClientInterface) que define c√≥mo deben realizarse los pagos: pagar(double monto). Todo el c√≥digo cliente (por ejemplo, la interfaz gr√°fica, o los controladores) ya trabaja con esta interfaz.

Ahora, quieren integrar un nuevo proveedor de pagos externo (como una API bancaria), que viene con su propia clase NuevoSistemaPago, la cual tiene un m√©todo completamente distinto: realizarTransaccion(double cantidad)

**Problema**: El nuevo sistema de pagos no es compatible con la interfaz existente.
No se puede modificar ni el nuevo sistema (porque es una librer√≠a externa) ni todo el c√≥digo cliente (porque ser√≠a muy costoso y riesgoso).

**Solucion**: Se aplica el patr√≥n Adapter.
Se crea una clase AdaptadorNuevoSistemaPago que:
- Implementa la interfaz esperada por el cliente (ProcesadorPago).
- Contiene una instancia del nuevo servicio (NuevoSistemaPago).
- Traduce las llamadas de pagar(monto) en llamadas a realizarTransaccion(cantidad).

**En codigo**
- **ClientInterface** ‚Äî Interfaz que espera el cliente
```
public interface ProcesadorPago {
    void pagar(double monto);
}
```
- **Service**: Clase externa (no modificable) con una interfaz incompatible
```
public class NuevoSistemaPago {
    public void realizarTransaccion(double cantidad) {
        System.out.println("Pago procesado por el NUEVO sistema: $" + cantidad);
    }
}
```
- **Adapter**: Adapta la clase externa al cliente
```
public class AdaptadorNuevoSistemaPago implements ProcesadorPago {
    private NuevoSistemaPago nuevoSistema;

    public AdaptadorNuevoSistemaPago(NuevoSistemaPago nuevoSistema) {
        this.nuevoSistema = nuevoSistema;
    }

    @Override
    public void pagar(double monto) {
        // Adaptamos el m√©todo esperado por el cliente al del servicio real
        nuevoSistema.realizarTransaccion(monto);
    }
}
```
- **Client**
```
public class Cliente {
    private ProcesadorPago procesador;

    public Cliente(ProcesadorPago procesador) {
        this.procesador = procesador;
    }

    public void realizarPago(double monto) {
        procesador.pagar(monto);
    }
}
```
- Main
```
public class Main {
    public static void main(String[] args) {
        NuevoSistemaPago sistemaExterno = new NuevoSistemaPago();
        ProcesadorPago adaptador = new AdaptadorNuevoSistemaPago(sistemaExterno);

        Cliente cliente = new Cliente(adaptador);
        cliente.realizarPago(150.0);
    }
}
```


## Proxy


# Patrones de comportamiento
Son patrones que definen c√≥mo los objetos interact√∫an y se comunican entre s√≠, centr√°ndose en la asignaci√≥n de responsabilidades y la implementaci√≥n de algoritmos. Se enfoca en como las clases y objetos se comunican entre ellas.

## Null object

## State

## Strategy

## Template Method

## Interpreter

![image](https://github.com/user-attachments/assets/c6b06a9f-ef37-4085-8698-ef1e214cd1cd)

## Visitor

## Observer
