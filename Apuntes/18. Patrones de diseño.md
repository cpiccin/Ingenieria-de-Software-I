# Patrones de diseño
**Creational patterns** provide object creation mechanisms that increase flexibility and reuse of existing code.

**Structural patterns** explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.

**Behavioral patterns** take care of effective communication and the assignment of responsibilities between objects.


# Patrones creacionales
Se enfocan en cómo crear objetos, separando el proceso de creación de su uso. Abordan el problema de cómo crear objetos de manera flexible y reutilizable, proporcionando mecanismos para la creación de objetos que no se basan en la creación directa de objetos. 

## Factory
**Aplicabilidad**: 
- Cuando desde una clase se desee crear y usar objetos sin que la misma quede acoplada a las clases de estos.
- Cuando una clase no pueda anticipar la clase de objetos que debe crear.
- Cuando una clase quiera que sean sus subclases las que especifiquen los objetos que crea.

**Estructura**

![image](https://github.com/user-attachments/assets/01fbcbc5-c789-4062-9714-e7ea87c8b27a)

- **Product** declara la interfaz, que es comun a todos los objetos que puede producir la clase creadora y sus subclases
- Los **ConcreteProduct** son distintas implementaciones de Product
- La clase **Creator** declara el metodo factory que devuelve nuevos objetos de producto. Coincide el tipo de retorno con el tipo de la interfaz de producto
- Los **ConcreteCreators** sobreescriben el Factory Method, devolviendo un tipo diferente de producto

*Efectos deseados*: El patrón sigue el Principio de Responsabilidad Única (la creación de los
objetos se concentra en las fábricas). Se disminuye el acoplamiento entre las clases.

### Ejemplo 1 
**Situacion**: Una aplicación fue diseñada inicialmente solo para transporte de paquetes en camión, con todo el código centrado en la clase Camión. Al querer añadir transporte marítimo, el fuerte acoplamiento al camión obliga a modificar gran parte del código. Esto complica la incorporación de nuevos tipos de transporte y lleva a un código desorganizado, lleno de condicionales según el tipo de transporte.

**Solucion**: El patrón Factory Method sugiere que, en lugar de llamar al operador new para construir objetos directamente, se invoque a un método fábrica especial. Los objetos se siguen creando a través del operador new, pero se invocan desde el método fábrica.

### Ejemplo 2
**Situacion**: Una aplicación de mensajería fue diseñada inicialmente solo para enviar correos electrónicos. Toda la lógica de envío de mensajes, validación y formato estaba escrita directamente en una clase MensajeEmail.

Los usuarios comenzaron a solicitar otros tipos de mensajes, como SMS y WhatsApp. Para agregarlos, el equipo tuvo que llenar el código de condicionales que preguntaban por el tipo de mensaje: `"si es email, hacer esto... si es SMS, hacer esto otro..."`. Esto hizo que el sistema fuera difícil de mantener, difícil de escalar, y muy propenso a errores cada vez que se quería agregar un nuevo tipo de mensaje.

El problema central era que el código estaba fuertemente **acoplado** a los tipos concretos de mensajes. Cada vez que se agregaba uno nuevo, era necesario modificar varias partes del sistema, violando el principio de abierto/cerrado (el código debería estar abierto a la extensión pero cerrado a la modificación).

**Solución**: En vez de instanciar directamente (new MensajeEmail()), delegamos la creación del objeto a un método fábrica. Este método es declarado en una clase abstracta (o interfaz), y cada tipo de mensaje tendrá su propia clase que implemente ese método, devolviendo el objeto adecuado.

**En codigo**

- Product
```
public interface Mensaje {
    void enviar(String destinatario, String contenido);
}
```
- ConcreteProduct
```
public class MensajeEmail implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando Email a " + destinatario + ": " + contenido);
    }
}

public class MensajeSMS implements Mensaje {
    public void enviar(String destinatario, String contenido) {
        System.out.println("Enviando SMS a " + destinatario + ": " + contenido);
    }
}
```
- Creator
```
public abstract class MensajeFactory {
    // Método Factory
    public abstract Mensaje crearMensaje();
}
```
- ConcreteCreator
```
public class EmailFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeEmail();
    }
}

public class SMSFactory extends MensajeFactory {
    public Mensaje crearMensaje() {
        return new MensajeSMS();
    }
}
```
- Cliente
```
public class Main {
    public static void main(String[] args) {
        MensajeFactory factory = new EmailFactory();  // puede cambiarse por SMSFactory
        Mensaje mensaje = factory.crearMensaje();
        mensaje.enviar("ana@example.com", "Hola Ana!");
    }
}
```


## Abstract Factory

## Builder

![image](https://github.com/user-attachments/assets/ba6cec00-0e9d-4b06-9fff-3f3fa8ba3b3b)

## Singleton



# Patrones estructurales
Son soluciones reutilizables que ayudan a resolver problemas comunes en la construcción de software al definir cómo se componen las clases y objetos para crear estructuras complejas. Se enfocan en la estructura de clases y objetos, utilizando herramientas para ensamblar objetos y clases en estructuras más grandes. 

Facilitan el diseño al identificar una forma simple de realizar relaciones entre entidades

## Decorator

## Adapter 

# Patrones de comportamiento
Son patrones que definen cómo los objetos interactúan y se comunican entre sí, centrándose en la asignación de responsabilidades y la implementación de algoritmos. Se enfoca en como las clases y objetos se comunican entre ellas.

## Null object

## State

## Strategy

## Template Method

## Interpreter

![image](https://github.com/user-attachments/assets/c6b06a9f-ef37-4085-8698-ef1e214cd1cd)

## Visitor

## Observer
